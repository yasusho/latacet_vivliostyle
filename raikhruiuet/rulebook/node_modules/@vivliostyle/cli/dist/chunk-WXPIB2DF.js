import {
  importNodeModule
} from "./chunk-FXUEYQRY.js";
import {
  DetailError,
  Logger,
  assertPubManifestSchema,
  cwd,
  debounce,
  getDefaultEpubOpfPath,
  getEpubRootDir,
  getFormattedError,
  isInContainer,
  isRunningOnWSL,
  isValidUri,
  openEpub,
  parseJsonc,
  pathContains,
  pathEquals,
  prettifySchemaError,
  readJSON,
  registerExitHandler,
  runExitHandlers,
  setupConfigFromFlags,
  statFileSync,
  touchTmpFile,
  useTmpDirectory,
  writeFileIfChanged
} from "./chunk-MDTA37GZ.js";
import {
  VivliostyleConfigSchema
} from "./chunk-YUYXQJDY.js";
import {
  CONTAINER_LOCAL_HOSTNAME,
  CONTAINER_URL,
  COVER_HTML_FILENAME,
  COVER_HTML_IMAGE_ALT,
  EMPTY_DATA_URI,
  EPUB_CONTAINER_XML,
  EPUB_LANDMARKS_COVER_ENTRY,
  EPUB_LANDMARKS_TITLE,
  EPUB_LANDMARKS_TOC_ENTRY,
  EPUB_NS,
  EPUB_OUTPUT_VERSION,
  MANIFEST_FILENAME,
  TOC_FILENAME,
  TOC_TITLE,
  VIEWER_ROOT_PATH,
  XML_DECLARATION,
  cliVersion,
  viewerRoot
} from "./chunk-4IIM6RSG.js";
import {
  __callDispose,
  __using
} from "./chunk-I7BWSAN6.js";

// src/config/load.ts
import fs from "node:fs";
import { createRequire } from "node:module";
import { pathToFileURL } from "node:url";
import upath from "upath";
import * as v from "valibot";
var require2 = createRequire(import.meta.url);
function locateVivliostyleConfig({
  config,
  cwd: cwd2 = cwd
}) {
  if (config) {
    return upath.resolve(cwd2, config);
  }
  return [".js", ".mjs", ".cjs", ".json"].map((ext) => upath.join(cwd2, `vivliostyle.config${ext}`)).find((p) => fs.existsSync(p));
}
async function loadVivliostyleConfig({
  config,
  configData,
  cwd: cwd2
}) {
  if (configData) {
    return v.parse(VivliostyleConfigSchema, configData);
  }
  const absPath = locateVivliostyleConfig({ config, cwd: cwd2 });
  if (!absPath) {
    return;
  }
  let parsedConfig;
  let jsonRaw;
  try {
    if (upath.extname(absPath) === ".json") {
      jsonRaw = fs.readFileSync(absPath, "utf8");
      parsedConfig = parseJsonc(jsonRaw);
    } else {
      delete require2.cache[require2.resolve(absPath)];
      const url = pathToFileURL(absPath);
      url.search = `version=${Date.now()}`;
      parsedConfig = (await import(
        /* @vite-ignore */
        url.href
      )).default;
      jsonRaw = JSON.stringify(parsedConfig, null, 2);
    }
  } catch (error) {
    const thrownError = error;
    throw new DetailError(
      `An error occurred on loading a config file: ${absPath}`,
      thrownError.stack ?? thrownError.message
    );
  }
  const result = v.safeParse(VivliostyleConfigSchema, parsedConfig);
  if (result.success) {
    const { tasks, inlineOptions } = result.output;
    return {
      tasks,
      inlineOptions: {
        ...inlineOptions,
        cwd: cwd2 ?? cwd,
        config: absPath
      }
    };
  } else {
    const errorString = prettifySchemaError(jsonRaw, result.issues);
    throw new DetailError(
      `Validation of vivliostyle config failed. Please check the schema: ${config}`,
      errorString
    );
  }
}
function warnDeprecatedConfig(config) {
  if (config.tasks.some((task) => task.includeAssets)) {
    Logger.logWarn(
      "'includeAssets' property of Vivliostyle config was deprecated and will be removed in a future release. Please use 'copyAsset.includes' property instead."
    );
  }
  if (config.tasks.some((task) => task.tocTitle)) {
    Logger.logWarn(
      "'tocTitle' property of Vivliostyle config was deprecated and will be removed in a future release. Please use 'toc.title' property instead."
    );
  }
  if (config.tasks.some((task) => task.http)) {
    Logger.logWarn(
      "'http' property of Vivliostyle config was deprecated and will be removed in a future release. This option is enabled by default, and the file protocol is no longer supported."
    );
  }
}

// src/config/merge.ts
var pruneObject = (obj) => {
  const ret = { ...obj };
  for (const key in ret) {
    if (ret[key] === void 0 || ret[key] === null) {
      delete ret[key];
    }
  }
  return ret;
};
function mergeConfig(base, override) {
  return {
    tasks: base.tasks.map((task, i) => ({
      ...pruneObject(task),
      ...pruneObject(override)
    })),
    inlineOptions: base.inlineOptions
  };
}
function mergeInlineConfig({ tasks, inlineOptions }, inlineConfig) {
  const {
    theme,
    size,
    pressReady,
    title,
    author,
    language,
    readingProgression,
    timeout,
    image,
    viewer,
    viewerParam,
    browser,
    output,
    renderMode,
    preflight,
    preflightOption,
    vite,
    viteConfigFile,
    host,
    port,
    ...overrideInlineOptions
  } = inlineConfig;
  return {
    tasks: tasks.map((task) => ({
      ...pruneObject(task),
      ...pruneObject({
        theme,
        size,
        pressReady,
        title,
        author,
        language,
        readingProgression,
        timeout,
        image,
        viewer,
        viewerParam,
        browser,
        vite,
        viteConfigFile
      }),
      output: (output?.length ? output : task.output)?.map((o) => ({
        ...pruneObject(o),
        ...pruneObject({
          renderMode,
          preflight,
          preflightOption
        })
      })),
      server: {
        ...pruneObject(task.server ?? {}),
        ...pruneObject({ host, port })
      }
    })),
    inlineOptions: {
      ...pruneObject(inlineOptions),
      ...pruneObject(
        overrideInlineOptions
      )
    }
  };
}

// src/config/resolve.ts
import { VFM } from "@vivliostyle/vfm";
import { lookup as mime } from "mime-types";
import fs3 from "node:fs";
import { fileURLToPath, pathToFileURL as pathToFileURL2 } from "node:url";
import npa from "npm-package-arg";
import upath2 from "upath";

// src/processor/markdown.ts
import {
  readMetadata
} from "@vivliostyle/vfm";
import fs2 from "node:fs";
import vfile from "vfile";
function safeReadMetadata(content) {
  try {
    return readMetadata(content);
  } catch {
    return {};
  }
}
async function processMarkdown(documentProcessorFactory, filepath, options = {}) {
  const markdownString = fs2.readFileSync(filepath, "utf8");
  const processor = documentProcessorFactory(
    options,
    safeReadMetadata(markdownString)
  );
  const processed = await processor.process(
    vfile({ path: filepath, contents: markdownString })
  );
  return processed;
}
function readMarkdownMetadata(filepath) {
  return safeReadMetadata(fs2.readFileSync(filepath, "utf8"));
}

// src/config/resolve.ts
var manuscriptMediaTypes = [
  "text/markdown",
  "text/html",
  "application/xhtml+xml"
];
var UseTemporaryServerRoot = Symbol("UseTemporaryServerRoot");
var DEFAULT_ASSET_EXTENSIONS = [
  "css",
  "css.map",
  "png",
  "jpg",
  "jpeg",
  "svg",
  "gif",
  "webp",
  "apng",
  "ttf",
  "otf",
  "woff",
  "woff2"
];
function isManuscriptMediaType(mediaType) {
  return !!(mediaType && manuscriptMediaTypes.includes(mediaType));
}
function isWebPubConfig(config) {
  return config.viewerInput.type === "webpub";
}
function isWebbookConfig(config) {
  return config.viewerInput.type === "webbook";
}
function parsePackageName(specifier, cwd2) {
  try {
    let result = npa(specifier, cwd2);
    if (result.type === "git" && result.saveSpec?.startsWith("github:")) {
      result = npa(`file:${specifier}`, cwd2);
    }
    return result;
  } catch (error) {
    return null;
  }
}
function parseTheme({
  theme,
  context,
  workspaceDir,
  themesDir
}) {
  const { specifier, import: importPath } = typeof theme === "string" ? { specifier: theme, import: void 0 } : theme;
  if (isValidUri(specifier)) {
    return {
      type: "uri",
      name: upath2.basename(specifier),
      location: specifier
    };
  }
  const stylePath = upath2.resolve(context, specifier);
  if (fs3.existsSync(stylePath) && stylePath.endsWith(".css")) {
    const sourceRelPath = upath2.relative(context, stylePath);
    return {
      type: "file",
      name: upath2.basename(specifier),
      source: stylePath,
      location: upath2.resolve(workspaceDir, sourceRelPath)
    };
  }
  const parsed = parsePackageName(specifier, context);
  if (!parsed) {
    throw new Error(`Invalid package name: ${specifier}`);
  }
  if (!parsed.registry && parsed.type !== "directory") {
    throw new Error(`This package specifier is not allowed: ${specifier}`);
  }
  let name = parsed.name;
  let resolvedSpecifier = specifier;
  if (parsed.type === "directory" && parsed.fetchSpec) {
    const pkgJsonPath = upath2.join(parsed.fetchSpec, "package.json");
    if (fs3.existsSync(pkgJsonPath)) {
      const packageJson = JSON.parse(fs3.readFileSync(pkgJsonPath, "utf8"));
      name = packageJson.name;
      resolvedSpecifier = parsed.fetchSpec;
    }
  }
  if (!name) {
    throw new Error(`Could not determine the package name: ${specifier}`);
  }
  return {
    type: "package",
    name,
    specifier: resolvedSpecifier,
    location: upath2.join(themesDir, "node_modules", name),
    registry: Boolean(parsed.registry),
    importPath
  };
}
function parsePageSize(size) {
  const [width, height, ...others] = `${size}`.split(",");
  if (!width || others.length) {
    throw new Error(`Cannot parse size: ${size}`);
  } else if (width && height) {
    return {
      width,
      height
    };
  } else {
    return {
      format: width
    };
  }
}
function parseFileMetadata({
  contentType,
  sourcePath,
  workspaceDir,
  themesDir
}) {
  const sourceDir = upath2.dirname(sourcePath);
  let title;
  let themes;
  if (contentType === "text/markdown") {
    const metadata = readMarkdownMetadata(sourcePath);
    title = metadata.title;
    if (metadata.vfm?.theme && themesDir) {
      themes = [metadata.vfm.theme].flat().filter(
        (entry) => !!entry && (typeof entry === "string" || typeof entry === "object")
      ).map(
        (theme) => parseTheme({
          theme,
          context: sourceDir,
          workspaceDir,
          themesDir
        })
      );
    }
  } else {
    const content = fs3.readFileSync(sourcePath, "utf8");
    title = content.match(/<title>([^<]*)<\/title>/)?.[1] || void 0;
  }
  return { title, themes };
}
function parseCustomStyle({
  customStyle,
  entryContextDir
}) {
  if (isValidUri(customStyle)) {
    return customStyle;
  }
  const stylePath = upath2.resolve(entryContextDir, customStyle);
  if (!pathContains(entryContextDir, stylePath)) {
    throw Error(
      `Custom style file ${customStyle} is not in ${entryContextDir}. Make sure the file is located in the context directory or a subdirectory.`
    );
  }
  if (!fs3.existsSync(stylePath)) {
    throw new Error(`Custom style file not found: ${customStyle}`);
  }
  return pathToFileURL2(stylePath).href.slice(
    pathToFileURL2(entryContextDir).href.replace(/\/$/, "").length + 1
  );
}
function resolveTaskConfig(config, options) {
  const context = options.cwd ?? cwd;
  Logger.debug("resolveTaskConfig > context %s", context);
  const entryContextDir = config.entryContext ? upath2.resolve(context, config.entryContext) : context;
  const language = config.language;
  const readingProgression = config.readingProgression;
  const size = config.size ? parsePageSize(config.size) : void 0;
  const cropMarks = options.cropMarks ?? false;
  const bleed = options.bleed;
  const cropOffset = options.cropOffset;
  const css = options.css;
  const singleDoc = options.singleDoc ?? false;
  const quick = options.quick ?? false;
  const temporaryFilePrefix = config.temporaryFilePrefix ?? `.vs-${Date.now()}.`;
  const documentProcessorFactory = config?.documentProcessor ?? VFM;
  const vfmOptions = {
    ...config?.vfm,
    hardLineBreaks: config?.vfm?.hardLineBreaks ?? false,
    disableFormatHtml: config?.vfm?.disableFormatHtml ?? false
  };
  const timeout = config.timeout ?? 3e5;
  const sandbox = options.sandbox ?? false;
  const browser = {
    type: config.browser ?? "chromium",
    executablePath: options.executableBrowser
  };
  const proxyServer = options.proxyServer ?? process.env.HTTP_PROXY ?? void 0;
  const proxy = proxyServer ? {
    server: proxyServer,
    bypass: options.proxyBypass ?? process.env.NOPROXY ?? void 0,
    username: options.proxyUser,
    password: options.proxyPass
  } : void 0;
  const image = config.image ?? `${CONTAINER_URL}:${cliVersion}`;
  const viewer = config.viewer ?? void 0;
  const viewerParam = config.viewerParam ?? void 0;
  const logLevel = options.logLevel ?? "silent";
  const ignoreHttpsErrors = options.ignoreHttpsErrors ?? false;
  const base = config.base ?? "/vivliostyle";
  const staticRoutes = config.static ?? {};
  const viteConfig = config.vite;
  const viteConfigFile = config.viteConfigFile ?? true;
  const customStyle = options.style && parseCustomStyle({ customStyle: options.style, entryContextDir }) || void 0;
  const customUserStyle = options.userStyle && parseCustomStyle({ customStyle: options.userStyle, entryContextDir }) || void 0;
  const outputs = (() => {
    const defaultPdfOptions = {
      format: "pdf",
      renderMode: options.renderMode ?? "local",
      preflight: options.preflight ?? (config.pressReady ? "press-ready" : void 0),
      preflightOption: options.preflightOption ?? []
    };
    if (config.output) {
      return config.output.map((target) => {
        const outputPath = upath2.resolve(context, target.path);
        const format = target.format;
        switch (format) {
          case "pdf":
            return {
              ...defaultPdfOptions,
              ...target,
              format,
              path: outputPath
            };
          case "epub":
            return {
              ...target,
              format,
              path: outputPath,
              version: EPUB_OUTPUT_VERSION
            };
          case "webpub":
            return {
              ...target,
              format,
              path: outputPath
            };
          default:
            return format;
        }
      });
    }
    const filename = config.title ? `${config.title}.pdf` : "output.pdf";
    return [
      {
        ...defaultPdfOptions,
        path: upath2.resolve(context, filename)
      }
    ];
  })();
  const { server, rootUrl } = (() => {
    let host = config.server?.host ?? false;
    let allowedHosts = config.server?.allowedHosts || [];
    const port = config.server?.port ?? 13e3;
    if (outputs.some(
      (target) => target.format === "pdf" && target.renderMode === "docker"
    ) && !isInContainer()) {
      host = true;
      if (Array.isArray(allowedHosts) && !allowedHosts.includes(CONTAINER_LOCAL_HOSTNAME)) {
        allowedHosts.push(CONTAINER_LOCAL_HOSTNAME);
      }
    }
    const rootHostname = !host ? "localhost" : host === true ? "0.0.0.0" : host;
    return {
      server: {
        host,
        port,
        proxy: config.server?.proxy ?? {},
        allowedHosts
      },
      rootUrl: `http://${rootHostname}:${port}`
    };
  })();
  const cover = config.cover && {
    src: upath2.resolve(entryContextDir, config.cover.src),
    name: config.cover.name || COVER_HTML_IMAGE_ALT
  };
  const copyAsset = {
    includes: config.copyAsset?.includes ?? config.includeAssets ?? [],
    excludes: config.copyAsset?.excludes ?? [],
    fileExtensions: [
      .../* @__PURE__ */ new Set([
        ...DEFAULT_ASSET_EXTENSIONS,
        ...config.copyAsset?.includeFileExtensions ?? []
      ])
    ].filter(
      (ext) => !(config.copyAsset?.excludeFileExtensions ?? []).includes(ext)
    )
  };
  const themeIndexes = /* @__PURE__ */ new Set();
  const projectConfig = !options.config && options.input ? resolveSingleInputConfig({
    config,
    input: options.input,
    context,
    temporaryFilePrefix,
    themeIndexes,
    base
  }) : resolveComposedProjectConfig({
    config,
    context,
    entryContextDir,
    outputs,
    temporaryFilePrefix,
    themeIndexes,
    cover
  });
  for (const output of outputs) {
    const relPath = upath2.relative(context, output.path);
    if (pathContains(output.path, entryContextDir) || pathEquals(output.path, entryContextDir)) {
      throw new Error(
        `The output path is set to "${relPath}", but this will overwrite the original manuscript file. Please specify a different path.`
      );
    }
    if (pathContains(output.path, projectConfig.workspaceDir) || pathEquals(output.path, projectConfig.workspaceDir)) {
      throw new Error(
        `The output path is set to "${relPath}", but this will overwrite the working directory of Vivliostyle. Please specify a different path.`
      );
    }
  }
  const { entries, workspaceDir } = projectConfig;
  const duplicatedTarget = entries.find(
    (v1, i) => entries.findLastIndex((v2) => v1.target === v2.target) !== i
  )?.target;
  if (duplicatedTarget) {
    const sourceFile = entries.find(
      (entry) => entry.target === duplicatedTarget && entry.source?.type === "file"
    )?.source;
    throw new Error(
      `The output path "${upath2.relative(workspaceDir, duplicatedTarget)}" will overwrite existing content.` + (sourceFile ? ` Please choose a different name for the source file: ${sourceFile.pathname}` : "")
    );
  }
  const resolvedConfig = {
    ...projectConfig,
    entryContextDir,
    outputs,
    themeIndexes,
    copyAsset,
    temporaryFilePrefix,
    size,
    cropMarks,
    bleed,
    cropOffset,
    css,
    customStyle,
    customUserStyle,
    singleDoc,
    quick,
    language,
    readingProgression,
    documentProcessorFactory,
    vfmOptions,
    cover,
    timeout,
    sandbox,
    browser,
    proxy,
    image,
    viewer,
    viewerParam,
    logLevel,
    ignoreHttpsErrors,
    base,
    server,
    static: staticRoutes,
    rootUrl,
    viteConfig,
    viteConfigFile
  };
  return resolvedConfig;
}
function resolveSingleInputConfig({
  config,
  input,
  context,
  temporaryFilePrefix,
  themeIndexes,
  base
}) {
  Logger.debug("entering single entry config mode");
  let serverRootDir;
  let sourcePath;
  let workspaceDir;
  const inputFormat = input.format;
  const title = config?.title;
  const author = config?.author;
  const entries = [];
  const exportAliases = [];
  let isLocalResource = true;
  if (isValidUri(input.entry)) {
    const url = new URL(input.entry);
    if (url.protocol === "file:") {
      sourcePath = fileURLToPath(url);
    } else {
      isLocalResource = false;
      sourcePath = input.entry;
    }
  } else {
    sourcePath = upath2.resolve(context, input.entry);
  }
  if (isLocalResource) {
    statFileSync(sourcePath);
    switch (input.format) {
      case "webbook":
      case "markdown":
      case "pub-manifest":
      case "epub":
        workspaceDir = upath2.dirname(sourcePath);
        break;
      case "epub-opf": {
        const rootDir = getEpubRootDir(sourcePath);
        if (!rootDir) {
          throw new Error(
            `Could not determine the EPUB root directory for the OPF file: ${sourcePath}`
          );
        }
        workspaceDir = rootDir;
        break;
      }
      default:
        return input.format;
    }
    serverRootDir = workspaceDir;
  } else {
    serverRootDir = UseTemporaryServerRoot;
    workspaceDir = context;
  }
  const themesDir = upath2.resolve(workspaceDir, "themes");
  if (input.format === "markdown") {
    const contentType = "text/markdown";
    const metadata = parseFileMetadata({
      contentType,
      sourcePath,
      workspaceDir
    });
    const target = upath2.resolve(
      workspaceDir,
      `${temporaryFilePrefix}${upath2.basename(sourcePath)}`
    ).replace(/\.md$/, ".html");
    touchTmpFile(target);
    const themes = metadata.themes ?? config.theme?.map(
      (theme) => parseTheme({
        theme,
        context,
        workspaceDir,
        themesDir
      })
    ) ?? [];
    themes.forEach((t) => themeIndexes.add(t));
    entries.push({
      contentType,
      source: {
        type: "file",
        pathname: sourcePath,
        contentType
      },
      target,
      title: metadata.title,
      themes
    });
    exportAliases.push({
      source: target,
      target: upath2.resolve(
        upath2.dirname(target),
        upath2.basename(sourcePath).replace(/\.md$/, ".html")
      )
    });
  }
  let fallbackTitle;
  let viewerInput;
  if (inputFormat === "markdown") {
    const manifestPath = upath2.resolve(
      workspaceDir,
      `${temporaryFilePrefix}${MANIFEST_FILENAME}`
    );
    touchTmpFile(manifestPath);
    exportAliases.push({
      source: manifestPath,
      target: upath2.resolve(workspaceDir, MANIFEST_FILENAME)
    });
    fallbackTitle = entries.length === 1 && entries[0].title ? entries[0].title : upath2.basename(sourcePath);
    viewerInput = {
      type: "webpub",
      manifestPath,
      needToGenerateManifest: true
    };
  } else if (inputFormat === "webbook") {
    let webbookEntryUrl;
    let webbookPath;
    if (isValidUri(sourcePath)) {
      const url = new URL(sourcePath);
      webbookEntryUrl = url.href;
    } else {
      const rootFileUrl = pathToFileURL2(workspaceDir).href;
      const urlPath = pathToFileURL2(sourcePath).href.slice(rootFileUrl.length);
      webbookEntryUrl = `${base}${urlPath}`;
      webbookPath = sourcePath;
    }
    viewerInput = { type: "webbook", webbookEntryUrl, webbookPath };
  } else if (inputFormat === "pub-manifest") {
    viewerInput = {
      type: "webpub",
      manifestPath: sourcePath,
      needToGenerateManifest: false
    };
  } else if (inputFormat === "epub-opf") {
    viewerInput = { type: "epub-opf", epubOpfPath: sourcePath };
  } else if (inputFormat === "epub") {
    viewerInput = {
      type: "epub",
      epubPath: sourcePath,
      epubTmpOutputDir: upath2.join(
        sourcePath,
        `../${temporaryFilePrefix}${upath2.basename(sourcePath)}`
      )
    };
  } else {
    return inputFormat;
  }
  return {
    serverRootDir,
    workspaceDir,
    themesDir,
    entries,
    input: {
      format: inputFormat,
      entry: sourcePath
    },
    viewerInput,
    exportAliases,
    title: title || fallbackTitle,
    author
  };
}
function resolveComposedProjectConfig({
  config,
  context,
  entryContextDir,
  outputs,
  temporaryFilePrefix,
  themeIndexes,
  cover
}) {
  Logger.debug("entering composed project config mode");
  const workspaceDir = upath2.resolve(
    context,
    config.workspaceDir ?? ".vivliostyle"
  );
  const themesDir = upath2.resolve(workspaceDir, "themes");
  const pkgJsonPath = upath2.resolve(context, "package.json");
  const pkgJson = fs3.existsSync(pkgJsonPath) ? readJSON(pkgJsonPath) : void 0;
  if (pkgJson) {
    Logger.debug("located package.json path", pkgJsonPath);
  }
  const exportAliases = [];
  const rootThemes = config.theme?.map(
    (theme) => parseTheme({
      theme,
      context,
      workspaceDir,
      themesDir
    })
  ) ?? [];
  rootThemes.forEach((t) => themeIndexes.add(t));
  const tocConfig = {
    tocTitle: config.toc?.title ?? config?.tocTitle ?? TOC_TITLE,
    target: upath2.resolve(workspaceDir, config.toc?.htmlPath ?? TOC_FILENAME),
    sectionDepth: config.toc?.sectionDepth ?? 0,
    transform: {
      transformDocumentList: config.toc?.transformDocumentList,
      transformSectionList: config.toc?.transformSectionList
    }
  };
  const coverHtml = config.cover && ("htmlPath" in config.cover && !config.cover.htmlPath ? void 0 : upath2.resolve(
    workspaceDir,
    config.cover?.htmlPath || COVER_HTML_FILENAME
  ));
  const ensureCoverImage = (src) => {
    const absPath = src && upath2.resolve(entryContextDir, src);
    if (absPath) {
      statFileSync(absPath, {
        errorMessage: "Specified cover image does not exist"
      });
    }
    return absPath;
  };
  const projectTitle = config?.title ?? pkgJson?.name;
  const projectAuthor = config?.author ?? pkgJson?.author;
  const isContentsEntry = (entry) => entry.rel === "contents";
  const isCoverEntry = (entry) => entry.rel === "cover";
  const isArticleEntry = (entry) => !isContentsEntry(entry) && !isCoverEntry(entry);
  function parseEntry(entry) {
    const getInputInfo = (entryPath) => {
      if (/^https?:/.test(entryPath)) {
        return {
          type: "uri",
          href: entryPath,
          rootDir: upath2.join(workspaceDir, new URL(entryPath).host)
        };
      } else if (entryPath.startsWith("/")) {
        return {
          type: "uri",
          href: entryPath,
          rootDir: upath2.join(workspaceDir, "localhost")
        };
      }
      const pathname = upath2.resolve(entryContextDir, entryPath);
      statFileSync(pathname);
      const contentType = mime(pathname);
      if (!isManuscriptMediaType(contentType)) {
        throw new Error(
          `Invalid manuscript type ${contentType} detected: ${entry}`
        );
      }
      return {
        type: "file",
        pathname,
        contentType,
        metadata: parseFileMetadata({
          contentType,
          sourcePath: pathname,
          workspaceDir,
          themesDir
        })
      };
    };
    const getTargetPath = (source) => {
      switch (source.type) {
        case "file":
          return upath2.resolve(
            workspaceDir,
            upath2.relative(entryContextDir, source.pathname).replace(/\.md$/, ".html")
          );
        case "uri": {
          const url = new URL(source.href, "a://dummy");
          let pathname = url.pathname;
          if (!/\.\w+$/.test(pathname)) {
            pathname = `${pathname.replace(/\/$/, "")}/index.html`;
          }
          return upath2.join(source.rootDir, pathname);
        }
        default:
          return source;
      }
    };
    if ((isContentsEntry(entry) || isCoverEntry(entry)) && entry.path) {
      const source = upath2.resolve(entryContextDir, entry.path);
      try {
        statFileSync(source);
      } catch (error) {
        Logger.logWarn(
          `The "path" option is set but the file does not exist: ${source}
Maybe you want to set the "output" field instead.`
        );
        entry.output = entry.path;
        entry.path = void 0;
      }
    }
    if (isContentsEntry(entry)) {
      const inputInfo = entry.path ? getInputInfo(entry.path) : void 0;
      const { metadata, ...template } = inputInfo || {};
      let target = entry.output ? upath2.resolve(workspaceDir, entry.output) : inputInfo && getTargetPath(inputInfo);
      const themes = entry.theme ? [entry.theme].flat().map(
        (theme) => parseTheme({
          theme,
          context,
          workspaceDir,
          themesDir
        })
      ) : metadata?.themes ?? [...rootThemes];
      themes.forEach((t) => themeIndexes.add(t));
      target ??= tocConfig.target;
      if (inputInfo?.type === "file" && pathEquals(inputInfo.pathname, target)) {
        const tmpPath = upath2.resolve(
          upath2.dirname(target),
          `${temporaryFilePrefix}${upath2.basename(target)}`
        );
        exportAliases.push({ source: tmpPath, target });
        touchTmpFile(tmpPath);
        target = tmpPath;
      }
      const parsedEntry = {
        rel: "contents",
        ...tocConfig,
        target,
        title: entry.title ?? metadata?.title ?? projectTitle,
        themes,
        pageBreakBefore: entry.pageBreakBefore,
        pageCounterReset: entry.pageCounterReset,
        ..."type" in template && { template }
      };
      return parsedEntry;
    }
    if (isCoverEntry(entry)) {
      const inputInfo = entry.path ? getInputInfo(entry.path) : void 0;
      const { metadata, ...template } = inputInfo || {};
      let target = entry.output ? upath2.resolve(workspaceDir, entry.output) : inputInfo && getTargetPath(inputInfo);
      const themes = entry.theme ? [entry.theme].flat().map(
        (theme) => parseTheme({
          theme,
          context,
          workspaceDir,
          themesDir
        })
      ) : metadata?.themes ?? [];
      themes.forEach((t) => themeIndexes.add(t));
      const coverImageSrc = ensureCoverImage(entry.imageSrc || cover?.src);
      if (!coverImageSrc) {
        throw new Error(
          `A CoverEntryConfig is set in the entry list but a location of cover file is not set. Please set 'cover' property in your config file.`
        );
      }
      target ??= upath2.resolve(
        workspaceDir,
        entry.path || coverHtml || COVER_HTML_FILENAME
      );
      if (inputInfo?.type === "file" && pathEquals(inputInfo.pathname, target)) {
        const tmpPath = upath2.resolve(
          upath2.dirname(target),
          `${temporaryFilePrefix}${upath2.basename(target)}`
        );
        exportAliases.push({ source: tmpPath, target });
        touchTmpFile(tmpPath);
        target = tmpPath;
      }
      const parsedEntry = {
        rel: "cover",
        target,
        title: entry.title ?? metadata?.title ?? projectTitle,
        themes,
        coverImageSrc,
        coverImageAlt: entry.imageAlt || cover?.name || COVER_HTML_IMAGE_ALT,
        pageBreakBefore: entry.pageBreakBefore,
        ..."type" in template && { template }
      };
      return parsedEntry;
    }
    if (isArticleEntry(entry)) {
      const inputInfo = getInputInfo(entry.path);
      const { metadata, ...source } = inputInfo;
      const target = entry.output ? upath2.resolve(workspaceDir, entry.output) : getTargetPath(inputInfo);
      const themes = entry.theme ? [entry.theme].flat().map(
        (theme) => parseTheme({ theme, context, workspaceDir, themesDir })
      ) : metadata?.themes ?? [...rootThemes];
      themes.forEach((t) => themeIndexes.add(t));
      const parsedEntry = {
        contentType: inputInfo.type === "file" ? inputInfo.contentType : "text/html",
        source,
        target,
        title: entry.title ?? metadata?.title ?? projectTitle,
        themes,
        ...entry.rel && { rel: entry.rel }
      };
      return parsedEntry;
    }
    return entry;
  }
  const entries = config.entry.map(parseEntry);
  let fallbackProjectTitle;
  if (!projectTitle) {
    if (entries.length === 1 && entries[0].title) {
      fallbackProjectTitle = entries[0].title;
    } else {
      fallbackProjectTitle = upath2.basename(outputs[0].path);
    }
  }
  if (!!config?.toc && !entries.find(({ rel }) => rel === "contents")) {
    entries.unshift({
      rel: "contents",
      ...tocConfig,
      themes: [...rootThemes]
    });
  }
  if (cover && coverHtml && !entries.find(({ rel }) => rel === "cover")) {
    entries.unshift({
      rel: "cover",
      target: coverHtml,
      title: projectTitle,
      themes: [],
      // Don't inherit rootThemes for cover documents
      coverImageSrc: ensureCoverImage(cover.src),
      coverImageAlt: cover.name
    });
  }
  return {
    serverRootDir: context,
    workspaceDir,
    themesDir,
    entries,
    input: {
      format: "pub-manifest",
      entry: upath2.join(workspaceDir, MANIFEST_FILENAME)
    },
    viewerInput: {
      type: "webpub",
      manifestPath: upath2.join(workspaceDir, MANIFEST_FILENAME),
      needToGenerateManifest: true
    },
    exportAliases,
    title: projectTitle || fallbackProjectTitle,
    author: projectAuthor
  };
}

// src/browser.ts
import fs4 from "node:fs";
async function launchBrowser({
  browserType,
  proxy,
  executablePath,
  headless,
  noSandbox,
  disableDevShmUsage
}) {
  const playwright = await importNodeModule("playwright-core");
  playwright.firefox.executablePath;
  const options = browserType === "chromium" ? {
    executablePath,
    chromiumSandbox: !noSandbox,
    headless,
    args: [
      // #579: disable web security to allow cross-origin requests
      "--disable-web-security",
      ...disableDevShmUsage ? ["--disable-dev-shm-usage"] : [],
      // #357: Set devicePixelRatio=1 otherwise it causes layout issues in HiDPI displays
      ...headless ? ["--force-device-scale-factor=1"] : [],
      // #565: Add --disable-gpu option when running on WSL
      ...isRunningOnWSL() ? ["--disable-gpu"] : [],
      // set Chromium language to English to avoid locale-dependent issues
      "--lang=en",
      ...!headless && process.platform === "darwin" ? ["", "-AppleLanguages", "(en)"] : []
    ],
    env: { ...process.env, LANG: "en.UTF-8" },
    proxy
  } : (
    // TODO: Investigate appropriate settings on Firefox & Webkit
    { executablePath, headless }
  );
  const browser = await playwright[browserType].launch(options);
  registerExitHandler("Closing browser", () => {
    browser.close();
  });
  return browser;
}
async function getExecutableBrowserPath(browserType) {
  const playwright = await importNodeModule("playwright-core");
  return playwright[browserType].executablePath();
}
function getFullBrowserName(browserType) {
  return {
    chromium: "Chromium",
    firefox: "Firefox",
    webkit: "Webkit"
  }[browserType];
}
function checkBrowserAvailability(path) {
  return fs4.existsSync(path);
}
async function downloadBrowser(browserType) {
  const { registry } = await importNodeModule("playwright-core/lib/server");
  const executable = registry.findExecutable(browserType);
  {
    var _stack = [];
    try {
      const _2 = __using(_stack, Logger.suspendLogging(
        "Rendering browser is not installed yet. Downloading now."
      ));
      await registry.install([executable], false);
    } catch (_) {
      var _error = _, _hasError = true;
    } finally {
      __callDispose(_stack, _error, _hasError);
    }
  }
  return executable.executablePath();
}
async function launchPreview({
  mode,
  url,
  onBrowserOpen,
  onPageOpen,
  config: { browser: browserConfig, proxy, sandbox, ignoreHttpsErrors }
}) {
  let executableBrowser = browserConfig.executablePath;
  if (executableBrowser) {
    if (!checkBrowserAvailability(executableBrowser)) {
      throw new Error(
        `Cannot find the browser. Please check the executable browser path: ${executableBrowser}`
      );
    }
  } else {
    executableBrowser = await getExecutableBrowserPath(browserConfig.type);
    if (!checkBrowserAvailability(executableBrowser)) {
      await downloadBrowser(browserConfig.type);
    }
  }
  Logger.debug(`Executing browser path: ${executableBrowser}`);
  const browser = await launchBrowser({
    browserType: browserConfig.type,
    proxy,
    executablePath: executableBrowser,
    headless: mode === "build",
    noSandbox: !sandbox,
    disableDevShmUsage: isInContainer()
  });
  await onBrowserOpen?.(browser);
  const page = await browser.newPage({
    viewport: mode === "build" ? (
      // This viewport size important to detect headless environment in Vivliostyle viewer
      // https://github.com/vivliostyle/vivliostyle.js/blob/73bcf323adcad80126b0175630609451ccd09d8a/packages/core/src/vivliostyle/vgen.ts#L2489-L2500
      {
        width: 800,
        height: 600
      }
    ) : null,
    ignoreHTTPSErrors: ignoreHttpsErrors
  });
  await onPageOpen?.(page);
  page.on("dialog", () => {
  });
  await page.goto(url);
  return { browser, page };
}

// src/server.ts
import fs11 from "node:fs";
import { URL as URL2 } from "node:url";
import upath11 from "upath";
import {
  createServer,
  preview
} from "vite";

// src/vite/vite-plugin-dev-server.ts
import escapeRe from "escape-string-regexp";
import { pathToFileURL as pathToFileURL6 } from "node:url";
import sirv from "sirv";
import upath8 from "upath";

// src/processor/asset.ts
import { copy } from "fs-extra/esm";
import fs5 from "node:fs";
import picomatch from "picomatch";
import { glob } from "tinyglobby";
import upath3 from "upath";
var GlobMatcher = class {
  constructor(matcherConfig) {
    this.matcherConfig = matcherConfig;
    this.#_matchers = matcherConfig.map(
      ({ patterns, ...options }) => picomatch(patterns, options)
    );
  }
  #_matchers;
  match(test) {
    return this.#_matchers.some((matcher) => matcher(test));
  }
  async glob(globOptions = {}) {
    return new Set(
      (await Promise.all(
        this.matcherConfig.map(
          (config) => glob({ ...config, ...globOptions })
        )
      )).flat()
    );
  }
};
function getIgnoreThemeDirectoryPatterns({
  themesDir,
  cwd: cwd2
}) {
  return pathContains(cwd2, themesDir) ? [
    `${upath3.relative(cwd2, themesDir)}/node_modules/*/example`,
    `${upath3.relative(cwd2, themesDir)}/node_modules/*/*/example`
  ] : [];
}
function getIgnoreAssetPatterns({
  outputs,
  entries,
  cwd: cwd2
}) {
  return [
    ...outputs.flatMap(
      ({ format, path: p }) => !pathContains(cwd2, p) ? [] : format === "webpub" ? upath3.join(upath3.relative(cwd2, p), "**") : upath3.relative(cwd2, p)
    ),
    ...entries.flatMap(({ template }) => {
      return template?.type === "file" && pathContains(cwd2, template.pathname) ? upath3.relative(cwd2, template.pathname) : [];
    })
  ];
}
function getWebPubResourceMatcher({
  outputs,
  themesDir,
  entries,
  cwd: cwd2,
  manifestPath
}) {
  return new GlobMatcher([
    {
      patterns: [
        `**/${upath3.relative(cwd2, manifestPath)}`,
        "**/*.{html,htm,xhtml,xht,css}"
      ],
      ignore: [
        ...getIgnoreAssetPatterns({
          cwd: cwd2,
          outputs,
          entries
        }),
        ...getIgnoreThemeDirectoryPatterns({
          cwd: cwd2,
          themesDir
        }),
        // Ignore node_modules in the root directory
        "node_modules/**",
        // only include dotfiles starting with `.vs-`
        "**/.!(vs-*)/**"
      ],
      dot: true,
      cwd: cwd2
    }
  ]);
}
function getAssetMatcher({
  copyAsset: { fileExtensions, includes, excludes },
  outputs,
  themesDir,
  entries,
  cwd: cwd2,
  ignore = []
}) {
  const ignorePatterns = [
    ...ignore,
    ...excludes,
    ...getIgnoreAssetPatterns({ outputs, entries, cwd: cwd2 })
  ];
  return new GlobMatcher([
    // Step 1: Glob files with an extension in `fileExtension`
    // Ignore files in node_modules directory, theme example files and files matched `excludes`
    {
      patterns: fileExtensions.map((ext) => `**/*.${ext}`),
      ignore: [
        "**/node_modules/**",
        ...ignorePatterns,
        ...getIgnoreThemeDirectoryPatterns({ themesDir, cwd: cwd2 })
      ],
      cwd: cwd2
    },
    // Step 2: Glob files matched with `includes`
    // Ignore only files matched `excludes`
    {
      patterns: includes,
      ignore: ignorePatterns,
      cwd: cwd2
    }
  ]);
}
async function copyAssets({
  entryContextDir,
  workspaceDir,
  copyAsset,
  outputs,
  themesDir,
  entries
}) {
  if (pathEquals(entryContextDir, workspaceDir)) {
    return;
  }
  const relWorkspaceDir = upath3.relative(entryContextDir, workspaceDir);
  const assets = await getAssetMatcher({
    copyAsset,
    cwd: entryContextDir,
    outputs,
    themesDir,
    entries,
    ignore: [
      // don't copy workspace itself
      ...relWorkspaceDir ? [upath3.join(relWorkspaceDir, "**")] : []
    ]
  }).glob({ followSymbolicLinks: true });
  Logger.debug("assets", assets);
  for (const asset of assets) {
    const target = upath3.join(workspaceDir, asset);
    fs5.mkdirSync(upath3.dirname(target), { recursive: true });
    await copy(upath3.resolve(entryContextDir, asset), target);
  }
}

// src/processor/compile.ts
import { copy as copy4, move } from "fs-extra/esm";
import fs9 from "node:fs";
import upath7 from "upath";
import serializeToXml2 from "w3c-xmlserializer";
import MIMEType2 from "whatwg-mimetype";

// src/output/webbook.ts
import { copy as copy3 } from "fs-extra/esm";
import { lookup as mime3 } from "mime-types";
import fs7 from "node:fs";
import { pathToFileURL as pathToFileURL5 } from "node:url";
import { glob as glob2 } from "tinyglobby";
import upath6 from "upath";

// src/processor/html.tsx
import jsdom, {
  ResourceLoader as BaseResourceLoader,
  JSDOM
} from "@vivliostyle/jsdom";
import DOMPurify from "dompurify";
import { toHtml } from "hast-util-to-html";
import { fileURLToPath as fileURLToPath2, pathToFileURL as pathToFileURL3 } from "node:url";
import upath4 from "upath";
import MIMEType from "whatwg-mimetype";
import { jsx, jsxs } from "hastscript/jsx-runtime";
var createVirtualConsole = (onError) => {
  const virtualConsole = new jsdom.VirtualConsole();
  virtualConsole.on("error", (message) => {
    Logger.debug("[JSDOM Console] error:", message);
  });
  virtualConsole.on("warn", (message) => {
    Logger.debug("[JSDOM Console] warn:", message);
  });
  virtualConsole.on("log", (message) => {
    Logger.debug("[JSDOM Console] log:", message);
  });
  virtualConsole.on("info", (message) => {
    Logger.debug("[JSDOM Console] info:", message);
  });
  virtualConsole.on("dir", (message) => {
    Logger.debug("[JSDOM Console] dir:", message);
  });
  virtualConsole.on("jsdomError", (error) => {
    if (error.message === "Could not parse CSS stylesheet") {
      return;
    }
    onError(
      new DetailError(
        "Error occurred when loading content",
        error.stack ?? error.message
      )
    );
  });
  return virtualConsole;
};
var htmlPurify = DOMPurify(
  // @ts-expect-error: jsdom.DOMWindow should have trustedTypes property
  new JSDOM("").window
);
var ResourceLoader = class _ResourceLoader extends BaseResourceLoader {
  static dataUrlOrigin = "http://localhost/";
  fetcherMap = /* @__PURE__ */ new Map();
  fetch(url, options) {
    Logger.debug(`[JSDOM] Fetching resource: ${url}`);
    const fetcher = super.fetch(url, options);
    if (fetcher) {
      this.fetcherMap.set(url, fetcher);
    }
    return fetcher;
  }
  static async saveFetchedResources({
    fetcherMap,
    rootUrl,
    outputDir,
    onError
  }) {
    const rootHref = rootUrl.startsWith("data:") ? _ResourceLoader.dataUrlOrigin : /^https?:/i.test(rootUrl) ? new URL("/", rootUrl).href : new URL(".", rootUrl).href;
    const normalizeToLocalPath = (urlString, mimeType) => {
      let url = new URL(urlString);
      url.hash = "";
      if (mimeType === "text/html" && !/\.html?$/.test(url.pathname)) {
        url.pathname = `${url.pathname.replace(/\/$/, "")}/index.html`;
      }
      let relTarget = upath4.relative(rootHref, url.href);
      return decodeURI(relTarget);
    };
    const fetchedResources = [];
    await Promise.allSettled(
      [...fetcherMap.entries()].flatMap(async ([url, fetcher]) => {
        if (!url.startsWith(rootHref)) {
          return [];
        }
        return fetcher.then(async (buffer) => {
          let encodingFormat;
          try {
            const contentType = fetcher.response?.headers["content-type"];
            if (contentType) {
              encodingFormat = new MIMEType(contentType).essence;
            }
          } catch (e) {
          }
          const relTarget = normalizeToLocalPath(url, encodingFormat);
          const target = upath4.join(outputDir, relTarget);
          fetchedResources.push({ url: relTarget, encodingFormat });
          writeFileIfChanged(target, buffer);
        }).catch(onError);
      })
    );
    return fetchedResources;
  }
};
async function getJsdomFromUrlOrFile({
  src,
  resourceLoader,
  virtualConsole = createVirtualConsole((error) => {
    throw error;
  })
}) {
  const url = isValidUri(src) ? new URL(src) : pathToFileURL3(src);
  let dom;
  if (url.protocol === "http:" || url.protocol === "https:") {
    dom = await JSDOM.fromURL(src, {
      virtualConsole,
      resources: resourceLoader
    });
  } else if (url.protocol === "file:") {
    if (resourceLoader) {
      const file = resourceLoader._readFile(fileURLToPath2(url));
      resourceLoader.fetcherMap.set(url.href, file);
    }
    dom = await JSDOM.fromFile(fileURLToPath2(url), {
      virtualConsole,
      resources: resourceLoader,
      contentType: src.endsWith(".xhtml") || src.endsWith(".xml") ? "application/xhtml+xml; charset=UTF-8" : "text/html; charset=UTF-8"
    });
  } else if (url.protocol === "data:") {
    const [head, body] = url.href.split(",", 2);
    const data = decodeURIComponent(body);
    const buffer = Buffer.from(
      data,
      /;base64$/i.test(head) ? "base64" : "utf8"
    );
    const dummyUrl = `${ResourceLoader.dataUrlOrigin}index.html`;
    if (resourceLoader) {
      let timeoutId;
      const promise = new Promise((resolve) => {
        timeoutId = setTimeout(resolve, 0, buffer);
      });
      promise.abort = () => {
        if (timeoutId !== void 0) {
          clearTimeout(timeoutId);
        }
      };
      resourceLoader.fetcherMap.set(dummyUrl, promise);
    }
    dom = new JSDOM(buffer.toString(), {
      virtualConsole,
      resources: resourceLoader,
      contentType: "text/html; charset=UTF-8",
      url: dummyUrl
    });
  } else {
    throw new Error(`Unsupported protocol: ${url.protocol}`);
  }
  return dom;
}
function getJsdomFromString({
  html,
  virtualConsole = createVirtualConsole((error) => {
    throw error;
  })
}) {
  return new JSDOM(html, {
    virtualConsole
  });
}
async function getStructuredSectionFromHtml(htmlPath, href) {
  const dom = await getJsdomFromUrlOrFile({ src: htmlPath });
  const { document } = dom.window;
  const allHeadings = [...document.querySelectorAll("h1, h2, h3, h4, h5, h6")].filter((el) => {
    return !el.matches("blockquote *");
  }).sort((a, b) => {
    const position = a.compareDocumentPosition(b);
    return position & 2 ? 1 : position & 4 ? -1 : 0;
  });
  function traverse(headers) {
    if (headers.length === 0) {
      return [];
    }
    const [head, ...tail] = headers;
    const section = head.parentElement;
    const id = head.id || section.id;
    const level = Number(head.tagName.slice(1));
    let i = tail.findIndex((s) => Number(s.tagName.slice(1)) <= level);
    i = i === -1 ? tail.length : i;
    return [
      {
        headingHtml: htmlPurify.sanitize(head.innerHTML),
        headingText: head.textContent?.trim().replace(/\s+/g, " ") || "",
        level,
        ...href && id && { href: `${href}#${encodeURIComponent(id)}` },
        ...id && { id },
        children: traverse(tail.slice(0, i))
      },
      ...traverse(tail.slice(i))
    ];
  }
  return traverse(allHeadings);
}
var getTocHtmlStyle = ({
  pageBreakBefore,
  pageCounterReset
}) => {
  if (!pageBreakBefore && typeof pageCounterReset !== "number") {
    return null;
  }
  return (
    /* css */
    `
${pageBreakBefore ? (
      /* css */
      `:root {
  break-before: ${pageBreakBefore};
}`
    ) : ""}
${// Note: `--vs-document-first-page-counter-reset` is reserved variable name in Vivliostyle base themes
    typeof pageCounterReset === "number" ? (
      /* css */
      `@page :nth(1) {
  --vs-document-first-page-counter-reset: page ${Math.floor(pageCounterReset - 1)};
  counter-reset: var(--vs-document-first-page-counter-reset);
}`
    ) : ""}
`
  );
};
var defaultTocTransform = {
  transformDocumentList: (nodeList) => (propsList) => {
    return /* @__PURE__ */ jsx("ol", { children: nodeList.map((a, i) => [a, propsList[i]]).flatMap(
      ([{ href, title, sections }, { children, ...otherProps }]) => {
        if (sections?.length === 1 && sections[0].level === 1) {
          return [children].flat().flatMap((e) => {
            if (e.type === "element" && e.tagName === "ol") {
              return e.children;
            }
            return e;
          });
        }
        return /* @__PURE__ */ jsxs("li", { ...otherProps, children: [
          /* @__PURE__ */ jsx("a", { ...{ href }, children: title }),
          children
        ] });
      }
    ) });
  },
  transformSectionList: (nodeList) => (propsList) => {
    return /* @__PURE__ */ jsx("ol", { children: nodeList.map((a, i) => [a, propsList[i]]).map(
      ([{ headingHtml, href, level }, { children, ...otherProps }]) => {
        const headingContent = {
          type: "raw",
          value: headingHtml
        };
        return /* @__PURE__ */ jsxs("li", { ...otherProps, "data-section-level": level, children: [
          href ? /* @__PURE__ */ jsx("a", { ...{ href }, children: headingContent }) : /* @__PURE__ */ jsx("span", { children: headingContent }),
          children
        ] });
      }
    ) });
  }
};
function generateDefaultTocHtml({
  language,
  title
}) {
  const toc = /* @__PURE__ */ jsxs("html", { lang: language, children: [
    /* @__PURE__ */ jsxs("head", { children: [
      /* @__PURE__ */ jsx("meta", { charset: "utf-8" }),
      /* @__PURE__ */ jsx("title", { children: title || "" }),
      /* @__PURE__ */ jsx("style", { "data-vv-style": true })
    ] }),
    /* @__PURE__ */ jsxs("body", { children: [
      /* @__PURE__ */ jsx("h1", { children: title || "" }),
      /* @__PURE__ */ jsx("nav", { id: "toc", role: "doc-toc" })
    ] })
  ] });
  return toHtml(toc);
}
async function generateTocListSection({
  entries,
  distDir,
  sectionDepth,
  transform = {}
}) {
  const {
    transformDocumentList = defaultTocTransform.transformDocumentList,
    transformSectionList = defaultTocTransform.transformSectionList
  } = transform;
  const structure = await Promise.all(
    entries.map(async (entry) => {
      const href = encodeURI(upath4.relative(distDir, entry.target));
      const sections = sectionDepth >= 1 ? await getStructuredSectionFromHtml(entry.target, href) : [];
      return {
        title: entry.title || upath4.basename(entry.target, ".html"),
        href: encodeURI(upath4.relative(distDir, entry.target)),
        sections,
        children: []
        // TODO
      };
    })
  );
  const docToc = transformDocumentList(structure)(
    structure.map((doc) => {
      function renderSectionList(sections) {
        const nodeList = sections.flatMap((section) => {
          if (section.level > sectionDepth) {
            return [];
          }
          return section;
        });
        if (nodeList.length === 0) {
          return [];
        }
        return transformSectionList(nodeList)(
          nodeList.map((node) => ({
            children: [renderSectionList(node.children || [])].flat()
          }))
        );
      }
      return {
        children: [renderSectionList(doc.sections || [])].flat()
      };
    })
  );
  return toHtml(docToc, { allowDangerousHtml: true });
}
async function processTocHtml(dom, {
  manifestPath,
  tocTitle,
  styleOptions = {},
  entries,
  distDir,
  sectionDepth,
  transform
}) {
  const { document } = dom.window;
  if (!document.querySelector(
    'link[rel="publication"][type="application/ld+json"]'
  )) {
    const l = document.createElement("link");
    l.setAttribute("rel", "publication");
    l.setAttribute("type", "application/ld+json");
    l.setAttribute("href", encodeURI(upath4.relative(distDir, manifestPath)));
    document.head.appendChild(l);
  }
  const style = document.querySelector("style[data-vv-style]");
  if (style) {
    const textContent = getTocHtmlStyle(styleOptions);
    if (textContent) {
      style.textContent = textContent;
    } else {
      style.remove();
    }
  }
  const nav = document.querySelector('nav, [role="doc-toc"]');
  if (nav && !nav.hasChildNodes()) {
    const h2 = document.createElement("h2");
    h2.textContent = tocTitle;
    nav.appendChild(h2);
    nav.innerHTML += await generateTocListSection({
      entries,
      distDir,
      sectionDepth,
      transform
    });
  }
  return dom;
}
var getCoverHtmlStyle = ({
  pageBreakBefore
}) => (
  /* css */
  `
${pageBreakBefore ? `:root {
  break-before: ${pageBreakBefore};
}` : ""}
body {
  margin: 0;
}
[role="doc-cover"] {
  display: block;
  width: 100vw;
  height: 100vh;
  object-fit: contain;
}
@page {
  margin: 0;
}
`
);
function generateDefaultCoverHtml({
  language,
  title
}) {
  const toc = /* @__PURE__ */ jsxs("html", { lang: language, children: [
    /* @__PURE__ */ jsxs("head", { children: [
      /* @__PURE__ */ jsx("meta", { charset: "utf-8" }),
      /* @__PURE__ */ jsx("title", { children: title || "" }),
      /* @__PURE__ */ jsx("style", { "data-vv-style": true })
    ] }),
    /* @__PURE__ */ jsx("body", { children: /* @__PURE__ */ jsx("section", { role: "region", "aria-label": "Cover", children: /* @__PURE__ */ jsx("img", { role: "doc-cover" }) }) })
  ] });
  return toHtml(toc);
}
async function processCoverHtml(dom, {
  imageSrc,
  imageAlt,
  styleOptions = {}
}) {
  const { document } = dom.window;
  const style = document.querySelector("style[data-vv-style]");
  if (style) {
    const textContent = getCoverHtmlStyle(styleOptions);
    if (textContent) {
      style.textContent = textContent;
    } else {
      style.remove();
    }
  }
  const cover = document.querySelector('img[role="doc-cover"]');
  if (cover && !cover.hasAttribute("src")) {
    cover.setAttribute("src", encodeURI(imageSrc));
  }
  if (cover && !cover.hasAttribute("alt")) {
    cover.setAttribute("alt", imageAlt);
  }
  return dom;
}
async function processManuscriptHtml(dom, {
  title,
  style,
  contentType,
  language
}) {
  const { document } = dom.window;
  if (title) {
    if (!document.querySelector("title")) {
      const t = document.createElement("title");
      document.head.appendChild(t);
    }
    document.title = title;
  }
  for (const s of style ?? []) {
    const l = document.createElement("link");
    l.setAttribute("rel", "stylesheet");
    l.setAttribute("type", "text/css");
    l.setAttribute("href", encodeURI(s));
    document.head.appendChild(l);
  }
  if (language) {
    if (contentType === "application/xhtml+xml") {
      if (!document.documentElement.getAttribute("xml:lang")) {
        document.documentElement.setAttribute("lang", language);
        document.documentElement.setAttribute("xml:lang", language);
      }
    } else {
      if (!document.documentElement.getAttribute("lang")) {
        document.documentElement.setAttribute("lang", language);
      }
    }
  }
  return dom;
}
async function fetchLinkedPublicationManifest({
  dom,
  resourceLoader,
  baseUrl
}) {
  const { document } = dom.window;
  const linkEl = document.querySelector('link[href][rel="publication"]');
  if (!linkEl) {
    return null;
  }
  const href = linkEl.getAttribute("href").trim();
  let manifest;
  let manifestUrl = baseUrl;
  if (href.startsWith("#")) {
    const scriptEl = document.getElementById(href.slice(1));
    if (scriptEl?.getAttribute("type") !== "application/ld+json") {
      return null;
    }
    Logger.debug(`Found embedded publication manifest: ${href}`);
    try {
      manifest = JSON.parse(scriptEl.innerHTML);
    } catch (error) {
      const thrownError = error;
      throw new DetailError(
        "Failed to parse manifest data",
        typeof thrownError.stack
      );
    }
  } else {
    Logger.debug(`Found linked publication manifest: ${href}`);
    const url = new URL(href, baseUrl);
    manifestUrl = url.href;
    const buffer = await resourceLoader.fetch(url.href);
    if (!buffer) {
      throw new Error(`Failed to fetch manifest JSON file: ${url.href}`);
    }
    const manifestJson = buffer.toString();
    try {
      manifest = JSON.parse(manifestJson);
    } catch (error) {
      const thrownError = error;
      throw new DetailError(
        "Failed to parse manifest data",
        typeof thrownError.stack
      );
    }
  }
  try {
    assertPubManifestSchema(manifest);
  } catch (error) {
    Logger.logWarn(
      `Publication manifest validation failed. Processing continues, but some problems may occur.
${error}`
    );
  }
  return {
    manifest: decodePublicationManifest(manifest),
    manifestUrl
  };
}
function parseTocDocument(dom) {
  const { document } = dom.window;
  const docTocEl = document.querySelectorAll('[role="doc-toc"]');
  if (docTocEl.length === 0) {
    return null;
  }
  const tocRoot = docTocEl.item(0);
  const parseTocItem = (element) => {
    if (element.tagName !== "LI") {
      return null;
    }
    const label = element.children.item(0);
    const ol = element.children.item(1);
    if (!label || label.tagName !== "A" && label.tagName !== "SPAN") {
      return null;
    }
    if (!ol || ol.tagName !== "OL") {
      return { element, label };
    }
    const children = Array.from(ol.children).reduce((acc, val) => {
      if (!acc) {
        return acc;
      }
      const res = parseTocItem(val);
      return res && [...acc, res];
    }, []);
    return children && {
      element,
      label,
      children
    };
  };
  let heading;
  for (let child of Array.from(tocRoot.children)) {
    if (child.tagName === "OL") {
      const children = Array.from(child.children).reduce((acc, val) => {
        if (!acc) {
          return acc;
        }
        const res = parseTocItem(val);
        return res && [...acc, res];
      }, []);
      return children && { element: tocRoot, heading, children };
    } else if (["H1", "H2", "H3", "H4", "H5", "H6", "HGROUP"].includes(child.tagName)) {
      heading = child;
    } else {
      return null;
    }
  }
  return null;
}
function parsePageListDocument(dom) {
  const { document } = dom.window;
  const docPageListEl = document.querySelectorAll('[role="doc-pagelist"]');
  if (docPageListEl.length === 0) {
    return null;
  }
  const pageListRoot = docPageListEl.item(0);
  let heading;
  for (let child of Array.from(pageListRoot.children)) {
    if (child.tagName === "OL") {
      const children = Array.from(child.children).reduce((acc, element) => {
        return acc && (element.tagName === "LI" ? [...acc, { element }] : null);
      }, []);
      return children && { element: pageListRoot, heading, children };
    } else if (["H1", "H2", "H3", "H4", "H5", "H6", "HGROUP"].includes(child.tagName)) {
      heading = child;
    } else {
      return null;
    }
  }
  return null;
}

// src/output/epub.ts
import archiver from "archiver";
import { lookup as lookupLanguage } from "bcp-47-match";
import { XMLBuilder } from "fast-xml-parser";
import { copy as copy2 } from "fs-extra/esm";
import GithubSlugger from "github-slugger";
import { lookup as mime2 } from "mime-types";
import fs6 from "node:fs";
import { pathToFileURL as pathToFileURL4 } from "node:url";
import upath5 from "upath";
import { v4 as uuid } from "uuid";
import serializeToXml from "w3c-xmlserializer";
var TOC_ID = "toc";
var LANDMARKS_ID = "landmarks";
var PAGELIST_ID = "page-list";
var COVER_IMAGE_MIMETYPES = [
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/svg+xml",
  "image/webp"
];
var changeExtname = (filepath, newExt) => {
  let ext = upath5.extname(filepath);
  return `${filepath.slice(0, -ext.length)}${newExt}`;
};
var getRelativeHref = (target, baseUrl, rootUrl) => {
  const absBasePath = upath5.join("/", baseUrl);
  const absRootPath = upath5.join("/", rootUrl);
  const hrefUrl = new URL(encodeURI(target), pathToFileURL4(absBasePath));
  if (hrefUrl.protocol !== "file:") {
    return target;
  }
  if (/\.html?$/.test(hrefUrl.pathname)) {
    hrefUrl.pathname = changeExtname(hrefUrl.pathname, ".xhtml");
  }
  const pathname = upath5.posix.relative(
    pathToFileURL4(upath5.dirname(absRootPath)).pathname,
    hrefUrl.pathname
  );
  return `${pathname}${hrefUrl.search}${hrefUrl.hash}`;
};
var normalizeLocalizableString = (value, availableLanguages) => {
  if (!value) {
    return;
  }
  const values = [value].flat().map((value2) => typeof value2 === "string" ? { value: value2 } : value2);
  const localizedValues = values.filter(
    (v2) => !!v2.language
  );
  const preferredLang = lookupLanguage(
    localizedValues.map((v2) => v2.language),
    availableLanguages
  );
  if (preferredLang) {
    return localizedValues[localizedValues.findIndex((v2) => v2.language === preferredLang)].value;
  }
  return values.find((v2) => !v2.language)?.value;
};
var appendManifestProperty = (entry, newProperty) => {
  entry.properties = entry.properties ? Array.from(/* @__PURE__ */ new Set([...entry.properties.split(" "), newProperty])).join(
    " "
  ) : newProperty;
};
async function exportEpub({
  webpubDir,
  entryHtmlFile,
  manifest,
  relManifestPath,
  target,
  epubVersion
}) {
  Logger.debug("Export EPUB", {
    webpubDir,
    entryHtmlFile,
    relManifestPath,
    target,
    epubVersion
  });
  const [tmpDir] = await useTmpDirectory();
  fs6.mkdirSync(upath5.join(tmpDir, "META-INF"), { recursive: true });
  await copy2(webpubDir, upath5.join(tmpDir, "EPUB"));
  const uid = `urn:uuid:${uuid()}`;
  const entryHtmlRelPath = entryHtmlFile && upath5.relative(webpubDir, upath5.resolve(webpubDir, entryHtmlFile));
  const findPublicationLink = (relType, list, filter) => [list].flat().find(
    (e) => typeof e === "object" && e.rel === relType && (!filter || filter(e))
  );
  const tocResource = findPublicationLink("contents", [
    ...[manifest.readingOrder || []].flat(),
    ...[manifest.resources || []].flat()
  ]);
  const pageListResource = findPublicationLink("pagelist", [
    ...[manifest.readingOrder || []].flat(),
    ...[manifest.resources || []].flat()
  ]);
  const pictureCoverResource = findPublicationLink(
    "cover",
    manifest.resources,
    (e) => COVER_IMAGE_MIMETYPES.includes(e.encodingFormat || mime2(e.url) || "")
  );
  const htmlCoverResource = findPublicationLink(
    "cover",
    [
      ...[manifest.readingOrder || []].flat(),
      ...[manifest.resources || []].flat()
    ],
    (e) => /\.html?$/.test(e.url)
  );
  const manifestItem = [
    ...[manifest.links || []].flat(),
    ...[manifest.readingOrder || []].flat(),
    ...[manifest.resources || []].flat()
  ].reduce(
    (acc, val) => {
      const { url, encodingFormat } = typeof val === "string" ? { url: val } : val;
      try {
        new URL(url);
        return acc;
      } catch (e) {
      }
      if (!fs6.existsSync(upath5.join(tmpDir, "EPUB", url))) {
        return acc;
      }
      const mediaType = encodingFormat || mime2(url) || "text/plain";
      acc[url] = {
        href: url,
        mediaType
      };
      if (/\.html?$/.test(url)) {
        acc[url].href = changeExtname(url, ".xhtml");
        acc[url].mediaType = "application/xhtml+xml";
      }
      if (url === pictureCoverResource?.url) {
        acc[url].properties = "cover-image";
      }
      return acc;
    },
    {}
  );
  const htmlFiles = Object.keys(manifestItem).filter(
    (url) => /\.html?$/.test(url)
  );
  let tocHtml = htmlFiles.find((f) => f === tocResource?.url);
  const readingOrder = [manifest.readingOrder || entryHtmlRelPath].flat().flatMap((v2) => v2 ? typeof v2 === "string" ? { url: v2 } : v2 : []);
  if (!tocHtml) {
    Logger.logWarn(
      "No table of contents document was found. for EPUB output, we recommend to enable `toc` option in your Vivliostyle config file to generate a table of contents document."
    );
    tocHtml = htmlFiles.find((f) => f === entryHtmlRelPath) || readingOrder[0].url;
  }
  const spineItems = readingOrder.map(({ url }) => ({
    href: changeExtname(url, ".xhtml")
  }));
  if (!(tocHtml in manifestItem)) {
    manifestItem[tocHtml] = {
      href: changeExtname(tocHtml, ".xhtml"),
      mediaType: "application/xhtml+xml"
    };
  }
  appendManifestProperty(manifestItem[tocHtml], "nav");
  const landmarks = [
    {
      type: "toc",
      href: `${manifestItem[tocHtml].href}#${TOC_ID}`,
      text: EPUB_LANDMARKS_TOC_ENTRY
    }
  ];
  if (htmlCoverResource) {
    landmarks.push({
      type: "cover",
      href: changeExtname(htmlCoverResource.url, ".xhtml"),
      text: EPUB_LANDMARKS_COVER_ENTRY
    });
  }
  const contextDir = upath5.join(tmpDir, "EPUB");
  const processHtml = async (target2) => {
    let parseResult;
    try {
      parseResult = await transpileHtmlToXhtml({
        target: target2,
        contextDir
      });
    } catch (error) {
      const thrownError = error;
      throw new DetailError(
        `Failed to transpile document to XHTML: ${target2}`,
        thrownError.stack ?? thrownError.message
      );
    }
    if (parseResult.hasMathmlContent) {
      appendManifestProperty(manifestItem[target2], "mathml");
    }
    if (parseResult.hasRemoteResources) {
      appendManifestProperty(manifestItem[target2], "remote-resources");
    }
    if (parseResult.hasScriptedContent) {
      appendManifestProperty(manifestItem[target2], "scripted");
    }
    if (parseResult.hasSvgContent) {
      appendManifestProperty(manifestItem[target2], "svg");
    }
    return parseResult;
  };
  const processResult = {};
  Logger.debug(`Transpiling ToC HTML to XHTML: ${tocHtml}`);
  processResult[tocHtml] = await processHtml(tocHtml);
  for (const target2 of htmlFiles.filter((f) => f !== tocHtml)) {
    Logger.debug(`Transpiling HTML to XHTML: ${target2}`);
    processResult[target2] = await processHtml(target2);
  }
  const { document: entryDocument } = processResult[tocHtml].dom.window;
  const docLanguages = [manifest.inLanguage].flat().filter((v2) => Boolean(v2));
  if (docLanguages.length === 0) {
    docLanguages.push(entryDocument.documentElement.lang || "en");
  }
  const docTitle = normalizeLocalizableString(manifest.name, docLanguages) || entryDocument.title;
  if (!docTitle) {
    throw new Error("EPUB must have a title of one or more characters");
  }
  const { tocResourceTree } = await processTocDocument({
    dom: processResult[tocHtml].dom,
    target: tocHtml,
    contextDir,
    readingOrder,
    docLanguages,
    landmarks
  });
  const pageListHtml = pageListResource?.url || entryHtmlRelPath;
  if (pageListHtml && pageListHtml in processResult) {
    await processPagelistDocument({
      dom: processResult[pageListHtml].dom,
      target: pageListHtml,
      contextDir
    });
  }
  if (relManifestPath) {
    await fs6.promises.rm(upath5.join(tmpDir, "EPUB", relManifestPath), {
      force: true,
      recursive: true
    });
    delete manifestItem[relManifestPath];
  }
  fs6.writeFileSync(
    upath5.join(tmpDir, "META-INF/container.xml"),
    EPUB_CONTAINER_XML,
    "utf8"
  );
  Logger.debug(`Generating content.opf`);
  fs6.writeFileSync(
    upath5.join(tmpDir, "EPUB/content.opf"),
    buildEpubPackageDocument({
      epubVersion,
      uid,
      docTitle,
      docLanguages,
      manifest,
      spineItems,
      manifestItems: Object.values(manifestItem)
    }),
    "utf8"
  );
  await compressEpub({ target, sourceDir: tmpDir });
}
async function writeAsXhtml(dom, absPath) {
  const xhtml = `${XML_DECLARATION}
${serializeToXml(dom.window.document)}`;
  await fs6.promises.writeFile(changeExtname(absPath, ".xhtml"), xhtml, "utf8");
}
async function transpileHtmlToXhtml({
  target,
  contextDir
}) {
  const absPath = upath5.join(contextDir, target);
  const dom = await getJsdomFromUrlOrFile({ src: absPath });
  const { document } = dom.window;
  document.documentElement.removeAttribute("xmlns");
  document.documentElement.setAttribute("xmlns:epub", EPUB_NS);
  document.querySelectorAll("a[href]").forEach((el) => {
    const href = decodeURI(el.getAttribute("href"));
    el.setAttribute("href", getRelativeHref(href, target, target));
  });
  await writeAsXhtml(dom, absPath);
  await fs6.promises.unlink(absPath);
  return {
    dom,
    // FIXME: Yes, I recognize this implementation is inadequate.
    hasMathmlContent: !!document.querySelector("math"),
    hasRemoteResources: !!document.querySelector(
      '[src^="http://"], [src^="https://"]'
    ),
    hasScriptedContent: !!document.querySelector("script, form"),
    hasSvgContent: !!document.querySelector("svg")
  };
}
function replaceWithNavElement(dom, el) {
  const nav = dom.window.document.createElement("nav");
  while (el.firstChild) {
    nav.appendChild(el.firstChild);
  }
  for (let i = 0; i < el.attributes.length; i++) {
    nav.attributes.setNamedItem(el.attributes[i].cloneNode());
  }
  el.parentNode?.replaceChild(nav, el);
  return nav;
}
async function processTocDocument({
  dom,
  target,
  contextDir,
  readingOrder,
  docLanguages,
  landmarks
}) {
  const { document } = dom.window;
  let tocResourceTree = null;
  if (!document.querySelector("nav[epub:type]")) {
    tocResourceTree = parseTocDocument(dom);
    if (tocResourceTree) {
      const nav = replaceWithNavElement(dom, tocResourceTree.element);
      nav.setAttribute("id", TOC_ID);
      nav.setAttribute("epub:type", "toc");
    } else {
      Logger.debug(`Generating toc nav element: ${target}`);
      const nav = document.createElement("nav");
      nav.setAttribute("id", TOC_ID);
      nav.setAttribute("role", "doc-toc");
      nav.setAttribute("epub:type", "toc");
      nav.setAttribute("hidden", "");
      const h2 = document.createElement("h2");
      h2.textContent = TOC_TITLE;
      nav.appendChild(h2);
      const ol = document.createElement("ol");
      tocResourceTree = {
        element: nav,
        children: []
      };
      for (const content of readingOrder) {
        let name = normalizeLocalizableString(content.name, docLanguages);
        if (!name) {
          const dom2 = await getJsdomFromUrlOrFile({
            src: upath5.join(contextDir, changeExtname(content.url, ".xhtml"))
          });
          name = dom2.window.document.title;
        }
        const li = document.createElement("li");
        const a = document.createElement("a");
        a.textContent = name;
        a.href = getRelativeHref(content.url, "", target);
        li.appendChild(a);
        ol.appendChild(li);
        tocResourceTree.children.push({ element: li, label: a });
      }
      nav.appendChild(ol);
      document.body.appendChild(nav);
      Logger.debug("Generated toc nav element", nav.outerHTML);
    }
    if (landmarks.length > 0) {
      Logger.debug(`Generating landmark nav element: ${target}`);
      const nav = document.createElement("nav");
      nav.setAttribute("epub:type", "landmarks");
      nav.setAttribute("id", LANDMARKS_ID);
      nav.setAttribute("hidden", "");
      const h2 = document.createElement("h2");
      h2.textContent = EPUB_LANDMARKS_TITLE;
      nav.appendChild(h2);
      const ol = document.createElement("ol");
      for (const { type, href, text } of landmarks) {
        const li = document.createElement("li");
        const a = document.createElement("a");
        a.setAttribute("epub:type", type);
        a.setAttribute("href", getRelativeHref(href, "", target));
        a.text = text;
        li.appendChild(a);
        ol.appendChild(li);
      }
      nav.appendChild(ol);
      document.body.appendChild(nav);
      Logger.debug("Generated landmark nav element", nav.outerHTML);
    }
  }
  const publicationLinkEl = document.querySelector(
    'link[href][rel="publication"]'
  );
  if (publicationLinkEl) {
    const href = publicationLinkEl.getAttribute("href").trim();
    if (href.startsWith("#")) {
      const scriptEl = document.getElementById(href.slice(1));
      if (scriptEl?.getAttribute("type") === "application/ld+json") {
        scriptEl.parentNode?.removeChild(scriptEl);
      }
    }
    publicationLinkEl.parentNode?.removeChild(publicationLinkEl);
  }
  const absPath = upath5.join(contextDir, target);
  await writeAsXhtml(dom, absPath);
  return { tocResourceTree };
}
async function processPagelistDocument({
  dom,
  target,
  contextDir
}) {
  const pageListResourceTree = parsePageListDocument(dom);
  if (pageListResourceTree) {
    const nav = replaceWithNavElement(dom, pageListResourceTree.element);
    nav.setAttribute("id", PAGELIST_ID);
    nav.setAttribute("epub:type", "page-list");
  }
  const absPath = upath5.join(contextDir, target);
  await writeAsXhtml(dom, absPath);
  return { pageListResourceTree };
}
function buildEpubPackageDocument({
  epubVersion,
  manifest,
  uid,
  docTitle,
  docLanguages,
  spineItems,
  manifestItems
}) {
  const slugger = new GithubSlugger();
  slugger.reset();
  const bookIdentifier = slugger.slug("bookid");
  const normalizeDate = (value) => value && `${new Date(value).toISOString().split(".")[0]}Z`;
  const transformToGenericTextNode = (value, attributes) => [value].flat().filter(Boolean).map((v2) => ({ ...attributes || {}, "#text": `${value}` }));
  const transformContributor = (contributorMap) => Object.entries(contributorMap).flatMap(
    ([type, contributor]) => contributor ? [contributor].flat().map((entry, index) => ({
      _id: slugger.slug(`${type}-${index + 1}`),
      "#text": typeof entry === "string" ? entry : normalizeLocalizableString(entry.name, docLanguages)
    })) : []
  );
  const itemIdMap = /* @__PURE__ */ new Map();
  manifestItems.forEach(({ href }) => {
    itemIdMap.set(href, slugger.slug(href));
  });
  const builder = new XMLBuilder({
    format: true,
    ignoreAttributes: false,
    attributeNamePrefix: "_"
  });
  return builder.build({
    "?xml": {
      _version: "1.0",
      _encoding: "UTF-8"
    },
    package: {
      _xmlns: "http://www.idpf.org/2007/opf",
      _version: epubVersion,
      "_unique-identifier": bookIdentifier,
      "_xml:lang": docLanguages[0],
      metadata: {
        "_xmlns:dc": "http://purl.org/dc/elements/1.1/",
        "dc:identifier": {
          _id: bookIdentifier,
          "#text": uid
        },
        "dc:title": docTitle,
        "dc:language": docLanguages,
        "dc:creator": transformContributor({
          // TODO: Define proper order
          author: manifest.author,
          creator: manifest.creator,
          editor: manifest.editor,
          artist: manifest.artist,
          illustrator: manifest.illustrator,
          colorist: manifest.colorist,
          penciler: manifest.penciler,
          inker: manifest.inker,
          letterer: manifest.letterer,
          translator: manifest.translator,
          readBy: manifest.readBy
        }),
        "dc:publisher": transformContributor({
          publisher: manifest.publisher
        }),
        "dc:contributor": transformContributor({
          contributor: manifest.contributor
        }),
        "dc:date": transformToGenericTextNode(
          normalizeDate(manifest.datePublished)
        ),
        "dc:rights": transformToGenericTextNode(
          manifest.copyrightHolder && `\xA9 ${manifest.copyrightYear ? `${manifest.copyrightYear} ` : ""}${manifest.copyrightHolder}`
        ),
        "dc:subject": transformToGenericTextNode(
          manifest["dc:subject"] || manifest.subject
        ),
        meta: [
          ...transformToGenericTextNode(
            normalizeDate(manifest.dateModified || Date.now()),
            {
              _property: "dcterms:modified"
            }
          ),
          ...(() => {
            const coverImage = manifestItems.find(
              (it) => it.properties === "cover-image"
            );
            return coverImage ? [{ _name: "cover", _content: itemIdMap.get(coverImage.href) }] : [];
          })()
        ]
      },
      manifest: {
        item: manifestItems.map(({ href, mediaType, properties }) => ({
          _id: itemIdMap.get(href),
          _href: encodeURI(href),
          "_media-type": mediaType,
          ...properties ? { _properties: properties } : {}
        }))
      },
      spine: {
        ...manifest.readingProgression ? { "_page-progression-direction": manifest.readingProgression } : {},
        itemref: [
          ...spineItems.map(({ href }) => ({
            _idref: itemIdMap.get(href)
          }))
        ]
      }
    }
  });
}
async function compressEpub({
  target,
  sourceDir
}) {
  Logger.debug(`Compressing EPUB: ${target}`);
  const output = fs6.createWriteStream(target);
  const archive = archiver("zip", {
    zlib: { level: 9 }
    // Compression level
  });
  return new Promise((resolve, reject) => {
    output.on("close", () => {
      Logger.debug(`Compressed EPUB: ${target}`);
      resolve();
    });
    output.on("error", reject);
    archive.on("warning", reject);
    archive.on("error", reject);
    archive.pipe(output);
    archive.append("application/epub+zip", {
      name: "mimetype",
      // mimetype should not be compressed
      // https://www.w3.org/TR/epub-33/#sec-zip-container-mime
      store: true
    });
    archive.directory(upath5.join(sourceDir, "META-INF"), "META-INF");
    archive.directory(upath5.join(sourceDir, "EPUB"), "EPUB");
    archive.finalize();
  });
}

// src/output/webbook.ts
function sortManifestResources(manifest) {
  if (!Array.isArray(manifest.resources)) {
    return;
  }
  manifest.resources = [...manifest.resources].sort(
    (a, b) => (typeof a === "string" ? a : a.url) > (typeof b === "string" ? b : b.url) ? 1 : -1
  );
}
async function prepareWebPublicationDirectory({
  outputDir
}) {
  if (fs7.existsSync(outputDir)) {
    Logger.debug("going to remove existing webpub", outputDir);
    await fs7.promises.rm(outputDir, { force: true, recursive: true });
  }
  fs7.mkdirSync(outputDir, { recursive: true });
}
function transformPublicationManifest(entity, transformer) {
  const { url: transformUrl } = transformer;
  const transformUrlOrPublicationLinks = (e) => {
    if (typeof e === "string") {
      return transformUrl(e);
    }
    const ret2 = { ...e };
    ret2.url = transformUrl(e.url);
    return ret2;
  };
  const ret = { ...entity };
  for (const [key, tr] of Object.entries({
    conformsTo: transformUrl,
    url: transformUrl,
    readingOrder: transformUrlOrPublicationLinks,
    resources: transformUrlOrPublicationLinks,
    links: transformUrlOrPublicationLinks
  })) {
    if (key in ret) {
      ret[key] = Array.isArray(ret[key]) ? ret[key].map(tr) : tr(ret[key]);
    }
  }
  return ret;
}
function decodePublicationManifest(input) {
  return transformPublicationManifest(input, {
    url: decodeURI
  });
}
function encodePublicationManifest(input) {
  return transformPublicationManifest(input, {
    url: encodeURI
  });
}
function writePublicationManifest(output, options) {
  const entries = options.entries.map((entry) => ({
    url: entry.path,
    ...entry.title && { name: entry.title },
    ...entry.encodingFormat && { encodingFormat: entry.encodingFormat },
    ...entry.rel && { rel: entry.rel },
    ...(entry.rel === "contents" || entry.rel === "cover") && {
      type: "LinkedResource"
    }
  }));
  const links = [
    options.links || []
  ].flat();
  const resources = [
    options.resources || []
  ].flat();
  if (options.cover) {
    const mimeType = mime3(options.cover.url);
    if (mimeType) {
      resources.push({
        rel: "cover",
        url: options.cover.url,
        name: options.cover.name,
        encodingFormat: mimeType
      });
    } else {
      Logger.logWarn(
        `Cover image "${options.cover}" was set in your configuration but couldn\u2019t detect the image metadata. Please check a valid cover file is placed.`
      );
    }
  }
  const publication = {
    "@context": ["https://schema.org", "https://www.w3.org/ns/pub-context"],
    type: "Book",
    conformsTo: "https://github.com/vivliostyle/vivliostyle-cli",
    ...options.title && { name: options.title },
    ...options.author && { author: options.author },
    ...options.language && { inLanguage: options.language },
    ...options.readingProgression && {
      readingProgression: options.readingProgression
    },
    dateModified: options.modified,
    readingOrder: entries,
    resources,
    links
  };
  const encodedManifest = encodePublicationManifest(publication);
  Logger.debug(
    "writePublicationManifest path: %s content: %O",
    output,
    encodedManifest
  );
  try {
    assertPubManifestSchema(encodedManifest);
  } catch (error) {
    const thrownError = error;
    throw new DetailError(
      `Validation of publication manifest failed. Please check the schema: ${output}`,
      typeof thrownError === "string" ? thrownError : thrownError.stack ?? thrownError.message
    );
  }
  fs7.mkdirSync(upath6.dirname(output), { recursive: true });
  fs7.writeFileSync(output, JSON.stringify(encodedManifest, null, 2));
  return publication;
}
async function retrieveWebbookEntry({
  viewerInput,
  outputDir
}) {
  const webbookEntryUrl = viewerInput.webbookPath ? pathToFileURL5(viewerInput.webbookPath).href : viewerInput.webbookEntryUrl;
  if (/^https?:/i.test(webbookEntryUrl)) {
    Logger.logUpdate("Fetching remote contents");
  }
  const resourceLoader = new ResourceLoader();
  const dom = await getJsdomFromUrlOrFile({
    src: webbookEntryUrl,
    resourceLoader
  });
  const entryHtml = viewerInput.webbookPath ? upath6.basename(viewerInput.webbookPath) : decodeURI(dom.window.location.pathname);
  const { manifest, manifestUrl } = await fetchLinkedPublicationManifest({
    dom,
    resourceLoader,
    baseUrl: webbookEntryUrl
  }) || {};
  let pathContains2;
  if (webbookEntryUrl.startsWith("data:")) {
    pathContains2 = (url) => false;
  } else {
    const rootUrl = /^https?:/i.test(webbookEntryUrl) ? new URL("/", webbookEntryUrl).href : new URL(".", webbookEntryUrl).href;
    pathContains2 = (url) => !upath6.relative(rootUrl, url).startsWith("..");
  }
  const retriever = new Map(resourceLoader.fetcherMap);
  if (manifest && manifestUrl) {
    [manifest.resources || []].flat().forEach((v2) => {
      const url = typeof v2 === "string" ? v2 : v2.url;
      const fullUrl = new URL(encodeURI(url), manifestUrl).href;
      if (!pathContains2(fullUrl) || retriever.has(fullUrl)) {
        return;
      }
      const fetchPromise = resourceLoader.fetch(fullUrl);
      if (fetchPromise && !retriever.has(fullUrl)) {
        retriever.set(fullUrl, fetchPromise);
      }
    });
    for (const v2 of [manifest.readingOrder || []].flat()) {
      const url = typeof v2 === "string" ? v2 : v2.url;
      if (!/\.html?$/.test(url) && !(typeof v2 === "string" || v2.encodingFormat === "text/html")) {
        continue;
      }
      const fullUrl = new URL(encodeURI(url), manifestUrl).href;
      if (!pathContains2(fullUrl) || fullUrl === webbookEntryUrl) {
        continue;
      }
      const subpathResourceLoader = new ResourceLoader();
      await getJsdomFromUrlOrFile({
        src: fullUrl,
        resourceLoader: subpathResourceLoader,
        virtualConsole: createVirtualConsole((error) => {
          Logger.logError(`Failed to fetch webbook resources: ${error.detail}`);
        })
      });
      subpathResourceLoader.fetcherMap.forEach(
        (v3, k) => !retriever.has(k) && retriever.set(k, v3)
      );
    }
  }
  const fetchedResources = await ResourceLoader.saveFetchedResources({
    fetcherMap: retriever,
    rootUrl: webbookEntryUrl,
    outputDir,
    /* v8 ignore next 4 */
    onError: (error) => {
      Logger.debug(error);
      Logger.logError(`Failed to fetch webbook resources: ${error}`);
    }
  });
  if (manifest) {
    const referencedContents = [
      ...[manifest.readingOrder || []].flat(),
      ...[manifest.resources || []].flat()
    ].map((v2) => typeof v2 === "string" ? v2 : v2.url);
    manifest.resources = [
      ...[manifest.resources || []].flat(),
      ...fetchedResources.filter(
        ({ url }) => !referencedContents.includes(url)
      )
    ];
    sortManifestResources(manifest);
  }
  Logger.debug(
    "Saved webbook resources",
    fetchedResources.map((v2) => v2.url)
  );
  Logger.debug(
    "Publication manifest from webbook",
    manifest && JSON.stringify(manifest, null, 2)
  );
  return {
    entryHtmlFile: upath6.join(
      outputDir,
      entryHtml,
      ...upath6.extname(entryHtml) ? [] : ["index.html"]
    ),
    manifest
  };
}
async function supplyWebPublicationManifestForWebbook({
  entryHtmlFile,
  outputDir,
  ...config
}) {
  Logger.debug(`Generating publication manifest from HTML: ${entryHtmlFile}`);
  const dom = await getJsdomFromUrlOrFile({ src: entryHtmlFile });
  const { document } = dom.window;
  const language = config.language || document.documentElement.lang || void 0;
  const title = config.title || document.title || "";
  const author = config.author || document.querySelector('meta[name="author"]')?.getAttribute("content") || "";
  const entry = upath6.relative(outputDir, entryHtmlFile);
  const allFiles = await glob2("**", {
    cwd: outputDir
  });
  const manifest = writePublicationManifest(
    upath6.join(outputDir, MANIFEST_FILENAME),
    {
      title,
      author,
      language,
      readingProgression: config.readingProgression,
      modified: (/* @__PURE__ */ new Date()).toISOString(),
      entries: [{ path: entry }],
      resources: allFiles.filter((f) => f !== entry)
    }
  );
  sortManifestResources(manifest);
  const link = document.createElement("link");
  link.setAttribute("rel", "publication");
  link.setAttribute("type", "application/ld+json");
  link.setAttribute(
    "href",
    upath6.relative(
      upath6.dirname(entryHtmlFile),
      upath6.join(outputDir, MANIFEST_FILENAME)
    )
  );
  document.head.appendChild(link);
  await fs7.promises.writeFile(entryHtmlFile, dom.serialize(), "utf8");
  Logger.debug(
    "Generated publication manifest from HTML",
    JSON.stringify(manifest, null, 2)
  );
  return manifest;
}
async function copyWebPublicationAssets({
  exportAliases,
  outputs,
  copyAsset,
  themesDir,
  manifestPath,
  input,
  outputDir,
  entries
}) {
  const relExportAliases = exportAliases.map(({ source, target }) => ({
    source: upath6.relative(input, source),
    target: upath6.relative(input, target)
  })).filter(({ source }) => !source.startsWith(".."));
  const assetMatcher = getAssetMatcher({
    copyAsset,
    cwd: input,
    outputs,
    themesDir,
    entries
  });
  const webResourceMatcher = getWebPubResourceMatcher({
    cwd: input,
    outputs,
    themesDir,
    entries,
    manifestPath
  });
  const allFiles = /* @__PURE__ */ new Set([
    ...await assetMatcher.glob(),
    ...await webResourceMatcher.glob({
      // follow symbolic links to copy local theme packages
      followSymbolicLinks: true
    })
  ]);
  for (const alias of relExportAliases) {
    allFiles.delete(alias.target);
  }
  Logger.debug(
    "webbook files",
    JSON.stringify(
      [...allFiles].map((file) => {
        const alias = relExportAliases.find(({ source }) => source === file);
        return alias ? `${file} (alias: ${alias.target})` : file;
      }),
      null,
      2
    )
  );
  const resources = [];
  let actualManifestPath = upath6.join(
    outputDir,
    upath6.relative(input, manifestPath)
  );
  for (const file of allFiles) {
    const alias = relExportAliases.find(({ source }) => source === file);
    const relTarget = alias?.target || file;
    resources.push(relTarget);
    const target = upath6.join(outputDir, relTarget);
    fs7.mkdirSync(upath6.dirname(target), { recursive: true });
    await copy3(upath6.join(input, file), target);
    if (alias && pathEquals(upath6.join(input, alias.source), manifestPath)) {
      actualManifestPath = target;
    }
  }
  Logger.debug("webbook publication.json", actualManifestPath);
  const manifest = decodePublicationManifest(
    JSON.parse(fs7.readFileSync(actualManifestPath, "utf8"))
  );
  for (const entry of relExportAliases) {
    const rewriteAliasPath = (e) => {
      if (typeof e === "string") {
        return pathEquals(e, entry.source) ? entry.source : e;
      }
      if (pathEquals(e.url, entry.source)) {
        e.url = entry.target;
      }
      return e;
    };
    if (manifest.links) {
      manifest.links = Array.isArray(manifest.links) ? manifest.links.map(rewriteAliasPath) : rewriteAliasPath(manifest.links);
    }
    if (manifest.readingOrder) {
      manifest.readingOrder = Array.isArray(manifest.readingOrder) ? manifest.readingOrder.map(rewriteAliasPath) : rewriteAliasPath(manifest.readingOrder);
    }
    if (manifest.resources) {
      manifest.resources = Array.isArray(manifest.resources) ? manifest.resources.map(rewriteAliasPath) : rewriteAliasPath(manifest.resources);
    }
  }
  const normalizeToUrl = (val) => [val || []].flat().map((e) => typeof e === "string" ? e : e.url);
  const preDefinedResources = [
    ...normalizeToUrl(manifest.links),
    ...normalizeToUrl(manifest.readingOrder),
    ...normalizeToUrl(manifest.resources)
  ];
  manifest.resources = [
    ...[manifest.resources || []].flat(),
    ...resources.flatMap((file) => {
      if (preDefinedResources.includes(file) || // Omit publication.json itself
      pathEquals(file, upath6.relative(outputDir, actualManifestPath))) {
        return [];
      }
      return file;
    })
  ];
  sortManifestResources(manifest);
  fs7.writeFileSync(
    actualManifestPath,
    JSON.stringify(encodePublicationManifest(manifest), null, 2)
  );
  return { manifest, actualManifestPath };
}
async function buildWebPublication({
  target,
  config
}) {
  let outputDir;
  if (target.format === "webpub") {
    outputDir = target.path;
    await prepareWebPublicationDirectory({ outputDir });
  } else {
    [outputDir] = await useTmpDirectory();
  }
  let entryHtmlFile;
  let manifest;
  let actualManifestPath;
  if (config.viewerInput.type === "webpub") {
    const ret = await copyWebPublicationAssets({
      ...config,
      input: config.workspaceDir,
      outputDir,
      manifestPath: config.viewerInput.manifestPath
    });
    manifest = ret.manifest;
    actualManifestPath = ret.actualManifestPath;
    if (config.input.format === "markdown") {
      const entry = [manifest.readingOrder].flat()[0];
      if (entry) {
        entryHtmlFile = upath6.join(
          outputDir,
          typeof entry === "string" ? entry : entry.url
        );
      }
    }
  } else if (isWebbookConfig(config)) {
    const ret = await retrieveWebbookEntry({
      viewerInput: config.viewerInput,
      outputDir
    });
    entryHtmlFile = ret.entryHtmlFile;
    manifest = ret.manifest || await supplyWebPublicationManifestForWebbook({
      ...config,
      entryHtmlFile: ret.entryHtmlFile,
      outputDir
    });
  } else {
    throw new Error("No entry specified");
  }
  if (target.format === "epub") {
    await exportEpub({
      webpubDir: outputDir,
      entryHtmlFile,
      manifest,
      relManifestPath: actualManifestPath && upath6.relative(outputDir, actualManifestPath),
      target: target.path,
      epubVersion: target.version
    });
  }
  return target.path;
}

// src/processor/theme.ts
import Arborist from "@npmcli/arborist";
import fs8 from "node:fs";
async function checkThemeInstallationNecessity({
  themesDir,
  themeIndexes
}) {
  if (!fs8.existsSync(themesDir)) {
    return [...themeIndexes].some((theme) => theme.type === "package");
  }
  const commonOpt = {
    path: themesDir,
    lockfileVersion: 3
  };
  const arb = new Arborist(commonOpt);
  const tree = await arb.loadActual();
  const pkgs = Array.from(tree.children.keys());
  return [...themeIndexes].some(
    (theme) => theme.type === "package" && !pkgs.includes(theme.name)
  );
}
async function installThemeDependencies({
  themesDir,
  themeIndexes
}) {
  fs8.mkdirSync(themesDir, { recursive: true });
  try {
    const commonOpt = {
      path: themesDir,
      lockfileVersion: 3
    };
    const tree = await new Arborist(commonOpt).buildIdealTree();
    const existing = Array.from(tree.children.keys());
    const add = [
      ...new Set(
        [...themeIndexes].flatMap(
          (theme) => theme.type === "package" ? [theme.specifier] : []
        )
      )
    ];
    const rm = existing.filter((v2) => !add.includes(v2));
    const opt = { ...commonOpt, rm, add };
    const arb = new Arborist(opt);
    await arb.reify(opt);
    return;
  } catch (error) {
    const thrownError = error;
    throw new DetailError(
      "An error occurred during the installation of the theme",
      thrownError.stack ?? thrownError.message
    );
  }
}

// src/processor/compile.ts
function locateThemePath(theme, from) {
  if (theme.type === "uri") {
    return theme.location;
  }
  if (theme.type === "file") {
    return upath7.relative(from, theme.location);
  }
  if (theme.importPath) {
    return [theme.importPath].flat().map((locator) => {
      const resolvedPath = upath7.resolve(theme.location, locator);
      if (!pathContains(theme.location, resolvedPath) || !fs9.existsSync(resolvedPath)) {
        throw new Error(
          `Could not find a style path ${theme.importPath} for the theme: ${theme.name}.`
        );
      }
      return upath7.relative(from, resolvedPath);
    });
  } else {
    const pkgJsonPath = upath7.join(theme.location, "package.json");
    const packageJson = JSON.parse(fs9.readFileSync(pkgJsonPath, "utf8"));
    const maybeStyle = packageJson?.vivliostyle?.theme?.style ?? packageJson.style ?? packageJson.main;
    if (!maybeStyle) {
      throw new DetailError(
        `Could not find a style file for the theme: ${theme.name}.`,
        "Please ensure this package satisfies a `vivliostyle.theme.style` property."
      );
    }
    return upath7.relative(from, upath7.join(theme.location, maybeStyle));
  }
}
async function cleanupWorkspace({
  entryContextDir,
  workspaceDir,
  themesDir,
  entries
}) {
  if (pathEquals(workspaceDir, entryContextDir) || pathContains(workspaceDir, entryContextDir) || entries.some(
    (entry) => entry.source?.type === "file" && pathContains(workspaceDir, entry.source.pathname)
  )) {
    return;
  }
  Logger.debug("cleanup workspace files", workspaceDir);
  let movedWorkspacePath;
  if (pathContains(workspaceDir, themesDir) && fs9.existsSync(themesDir)) {
    movedWorkspacePath = upath7.join(
      upath7.dirname(workspaceDir),
      `.vs-${Date.now()}`
    );
    const movedThemePath = upath7.join(
      movedWorkspacePath,
      upath7.relative(workspaceDir, themesDir)
    );
    fs9.mkdirSync(upath7.dirname(movedThemePath), { recursive: true });
    registerExitHandler(
      `Removing the moved workspace directory: ${movedWorkspacePath}`,
      () => {
        if (movedWorkspacePath && fs9.existsSync(movedWorkspacePath)) {
          fs9.rmSync(movedWorkspacePath, { recursive: true, force: true });
        }
      }
    );
    await move(themesDir, movedThemePath);
  }
  await fs9.promises.rm(workspaceDir, { recursive: true, force: true });
  if (movedWorkspacePath) {
    await move(movedWorkspacePath, workspaceDir);
  }
}
async function prepareThemeDirectory({
  themesDir,
  themeIndexes
}) {
  if (fs9.existsSync(upath7.join(themesDir, "packages")) && !fs9.existsSync(upath7.join(themesDir, "node_modules"))) {
    fs9.renameSync(
      upath7.join(themesDir, "packages"),
      upath7.join(themesDir, "node_modules")
    );
  }
  if (await checkThemeInstallationNecessity({ themesDir, themeIndexes })) {
    Logger.startLogging("Installing theme files");
    await installThemeDependencies({ themesDir, themeIndexes });
  }
  for (const theme of themeIndexes) {
    if (theme.type === "file" && !pathEquals(theme.source, theme.location)) {
      fs9.mkdirSync(upath7.dirname(theme.location), { recursive: true });
      await copy4(theme.source, theme.location);
    }
  }
}
async function transformManuscript(entry, {
  entryContextDir,
  workspaceDir,
  viewerInput: { manifestPath },
  title,
  entries,
  language,
  documentProcessorFactory,
  vfmOptions,
  rootUrl
}) {
  const source = entry.rel === "contents" || entry.rel === "cover" ? entry.template : entry.source;
  let content;
  let resourceLoader;
  let resourceUrl;
  const style = entry.themes.flatMap(
    (theme) => locateThemePath(theme, upath7.dirname(entry.target))
  );
  if (source?.type === "file") {
    if (source.contentType === "text/markdown") {
      const vfile2 = await processMarkdown(
        documentProcessorFactory,
        source.pathname,
        {
          ...vfmOptions,
          style,
          title: entry.title,
          language: language ?? void 0
        }
      );
      content = getJsdomFromString({ html: String(vfile2) });
    } else if (source.contentType === "text/html" || source.contentType === "application/xhtml+xml") {
      content = await getJsdomFromUrlOrFile({ src: source.pathname });
      content = await processManuscriptHtml(content, {
        style,
        title: entry.title,
        contentType: source.contentType,
        language
      });
    } else {
      if (!pathEquals(source.pathname, entry.target)) {
        await copy4(source.pathname, entry.target);
      }
    }
  } else if (source?.type === "uri") {
    resourceUrl = /^https?:/.test(source.href) ? source.href : `${rootUrl}${source.href}`;
    resourceLoader = new ResourceLoader();
    try {
      await getJsdomFromUrlOrFile({
        src: resourceUrl,
        resourceLoader,
        virtualConsole: createVirtualConsole((error) => {
          Logger.logError(`Failed to fetch resources: ${error.detail}`);
        })
      });
    } catch (error) {
      throw new DetailError(
        `Failed to fetch the content from ${resourceUrl}`,
        error.stack ?? error.message
      );
    }
    const contentFetcher = resourceLoader.fetcherMap.get(resourceUrl);
    if (contentFetcher) {
      const buffer = await contentFetcher;
      const contentType = contentFetcher.response?.headers["content-type"];
      if (!contentType || new MIMEType2(contentType).essence !== "text/html") {
        throw new Error(`The content is not an HTML document: ${resourceUrl}`);
      }
      content = getJsdomFromString({ html: buffer.toString("utf8") });
      content = await processManuscriptHtml(content, {
        style,
        title: entry.title,
        contentType: "text/html",
        language
      });
    }
  } else if (entry.rel === "contents") {
    content = getJsdomFromString({
      html: generateDefaultTocHtml({
        language,
        title
      })
    });
    content = await processManuscriptHtml(content, {
      style,
      title,
      contentType: "text/html",
      language
    });
  } else if (entry.rel === "cover") {
    content = getJsdomFromString({
      html: generateDefaultCoverHtml({ language, title: entry.title })
    });
    content = await processManuscriptHtml(content, {
      style,
      title: entry.title,
      contentType: "text/html",
      language
    });
  }
  if (!content) {
    return;
  }
  if (entry.rel === "contents") {
    const contentsEntry = entry;
    const manuscriptEntries = entries.filter(
      (e) => "source" in e
    );
    content = await processTocHtml(content, {
      entries: manuscriptEntries,
      manifestPath,
      distDir: upath7.dirname(contentsEntry.target),
      tocTitle: contentsEntry.tocTitle,
      sectionDepth: contentsEntry.sectionDepth,
      styleOptions: contentsEntry,
      transform: contentsEntry.transform
    });
  }
  if (entry.rel === "cover") {
    const coverEntry = entry;
    content = await processCoverHtml(content, {
      imageSrc: upath7.relative(
        upath7.join(
          entryContextDir,
          upath7.relative(workspaceDir, coverEntry.target),
          ".."
        ),
        coverEntry.coverImageSrc
      ),
      imageAlt: coverEntry.coverImageAlt,
      styleOptions: coverEntry
    });
  }
  let html;
  if (content.window.document.contentType === "application/xhtml+xml") {
    html = `${XML_DECLARATION}
${serializeToXml2(content.window.document)}`;
  } else {
    html = content.serialize();
  }
  const htmlBuffer = Buffer.from(html, "utf8");
  if (!source || source.type === "file" && !pathEquals(source.pathname, entry.target)) {
    writeFileIfChanged(entry.target, htmlBuffer);
  }
  if (source?.type === "uri" && resourceLoader && resourceUrl) {
    const { response } = resourceLoader.fetcherMap.get(resourceUrl);
    const contentFetcher = Promise.resolve(
      htmlBuffer
    );
    contentFetcher.abort = () => {
    };
    contentFetcher.response = response;
    resourceLoader.fetcherMap.set(resourceUrl, contentFetcher);
    await ResourceLoader.saveFetchedResources({
      fetcherMap: resourceLoader.fetcherMap,
      rootUrl: resourceUrl,
      outputDir: source.rootDir
    });
  }
  return html;
}
async function generateManifest({
  entryContextDir,
  workspaceDir,
  viewerInput: { manifestPath },
  title,
  author,
  entries,
  language,
  readingProgression,
  cover
}) {
  const manifestEntries = entries.map((entry) => ({
    title: entry.rel === "contents" && entry.tocTitle || entry.title,
    path: upath7.relative(workspaceDir, entry.target),
    encodingFormat: !("contentType" in entry) || entry.contentType === "text/markdown" || entry.contentType === "text/html" ? void 0 : entry.contentType,
    rel: entry.rel
  }));
  writePublicationManifest(manifestPath, {
    title,
    author,
    language,
    readingProgression,
    cover: cover && {
      url: upath7.relative(entryContextDir, cover.src),
      name: cover.name
    },
    entries: manifestEntries,
    modified: (/* @__PURE__ */ new Date()).toISOString()
  });
}
async function compile(config) {
  const tocEntries = [];
  for (const entry of config.entries) {
    if (entry.rel === "contents") {
      tocEntries.push(entry);
      continue;
    }
    await transformManuscript(entry, config);
  }
  for (const entry of tocEntries) {
    await transformManuscript(entry, config);
  }
  if (config.viewerInput.needToGenerateManifest) {
    await generateManifest(config);
  }
}

// src/vite/plugin-util.ts
var headStartTagRe = /<head[^>]*>/i;
var prependToHead = (html, content) => html.replace(headStartTagRe, (match) => `${match}
${content}`);
async function reloadConfig(prevConfig, inlineConfig, resolvedViteConfig) {
  let config = await loadVivliostyleConfig(inlineConfig) ?? setupConfigFromFlags(inlineConfig);
  config = mergeInlineConfig(config, inlineConfig);
  config = mergeConfig(config, {
    temporaryFilePrefix: prevConfig.temporaryFilePrefix,
    server: resolvedViteConfig?.server
  });
  const taskConfig = resolveTaskConfig(config.tasks[0], config.inlineOptions);
  return taskConfig;
}

// src/vite/vite-plugin-dev-server.ts
function createEntriesRouteLookup(entries, cwd2) {
  const extns = ["", "html", "htm"];
  const toAssume = (uri) => {
    let i = 0, x, len = uri.length - 1;
    if (uri.charCodeAt(len) === 47) {
      uri = uri.substring(0, len);
    }
    let arr = [], tmp = `${uri}/index`;
    for (; i < extns.length; i++) {
      x = extns[i] ? `.${extns[i]}` : "";
      if (uri) arr.push(uri + x);
      arr.push(tmp + x);
    }
    return arr;
  };
  const cache = entries.reduce((acc, e) => {
    acc[`/${upath8.relative(cwd2, e.target).normalize().replace(/\\+/g, "/")}`] = e;
    return acc;
  }, {});
  return (uri) => {
    let i = 0, data, arr = toAssume(uri);
    for (; i < arr.length; i++) {
      if (data = cache[arr[i]]) return [data, arr[i]];
    }
  };
}
function getWorkspaceMatcher({
  workspaceDir,
  themesDir,
  viewerInput,
  themeIndexes,
  entries,
  outputs
}) {
  if (viewerInput.type === "webpub") {
    return getWebPubResourceMatcher({
      outputs,
      themesDir,
      entries,
      cwd: workspaceDir,
      manifestPath: viewerInput.manifestPath
    });
  }
  let entryFiles = [];
  switch (viewerInput.type) {
    case "epub":
      entryFiles = [
        upath8.join(
          upath8.relative(workspaceDir, viewerInput.epubTmpOutputDir),
          "**"
        )
      ];
      break;
    case "epub-opf":
    case "webbook":
      entryFiles = ["**"];
      break;
    default:
      entryFiles = viewerInput;
  }
  return new GlobMatcher([
    {
      patterns: entryFiles,
      ignore: ["node_modules/**"],
      dot: true,
      cwd: workspaceDir
    }
  ]);
}
function vsDevServerPlugin({
  config: _config,
  inlineConfig
}) {
  let config = _config;
  let server;
  let program;
  const transformCache = /* @__PURE__ */ new Map();
  let matchProjectDep;
  async function reload(forceUpdate = false) {
    const prevConfig = config;
    config = await reloadConfig(prevConfig, inlineConfig, server?.config);
    transformCache.clear();
    const needToUpdateManifest = forceUpdate || // FIXME: More precise comparison
    JSON.stringify(prevConfig) !== JSON.stringify(config);
    if (isWebPubConfig(config) && config.viewerInput.needToGenerateManifest && needToUpdateManifest) {
      await generateManifest(config);
    }
    await prepareThemeDirectory(config);
    const entriesLookup = createEntriesRouteLookup(
      config.entries,
      config.workspaceDir
    );
    const urlMatchRe = new RegExp(
      `^${escapeRe(config.base)}(/[^?#]*)([?#].*)?$`
    );
    const serveWorkspace = sirv(config.workspaceDir, {
      dev: true,
      etag: false,
      dotfiles: true,
      extensions: []
    });
    const serveWorkspaceMatcher = getWorkspaceMatcher(config);
    const serveAssets = sirv(config.entryContextDir, {
      dev: true,
      etag: false,
      extensions: []
    });
    const serveAssetsMatcher = getAssetMatcher({
      ...config,
      cwd: config.entryContextDir
    });
    program = {
      entriesLookup,
      urlMatchRe,
      serveWorkspace,
      serveWorkspaceMatcher,
      serveAssets,
      serveAssetsMatcher
    };
    if (needToUpdateManifest) {
      Logger.debug(
        "dev-server > serveWorkspaceMatcher %O",
        serveWorkspaceMatcher.matcherConfig
      );
      Logger.debug(
        "dev-server > serveAssetsMatcher %O",
        serveAssetsMatcher.matcherConfig
      );
    }
    const configPath = locateVivliostyleConfig(inlineConfig);
    const projectDeps = [];
    if (configPath) {
      projectDeps.push(configPath);
      server?.watcher.add(configPath);
    }
    if (config.viewerInput.type === "webpub") {
      projectDeps.push(config.viewerInput.manifestPath);
      server?.watcher.add(config.viewerInput.manifestPath);
    }
    const flattenWatchTarget = (themes) => [...themes].flatMap((theme) => {
      if (theme.type === "file") {
        return [theme.source];
      }
      if (theme.type === "package" && !theme.registry) {
        return [theme.specifier];
      }
      return [];
    });
    const prevThemeFiles = flattenWatchTarget(prevConfig.themeIndexes);
    const themeFiles = flattenWatchTarget(config.themeIndexes);
    server?.watcher.unwatch(
      prevThemeFiles.filter((target) => !themeFiles.includes(target))
    );
    server?.watcher.add(themeFiles);
    projectDeps.push(...themeFiles);
    matchProjectDep = (pathname) => projectDeps.some(
      (dep) => pathEquals(dep, pathname) || pathContains(dep, pathname)
    );
  }
  async function transform(entry, host) {
    if (!isWebPubConfig(config)) {
      return;
    }
    const rootUrl = host ? `${server?.config.server.https ? "https" : "http"}://${host}` : config.rootUrl;
    const promise = (async () => {
      try {
        const html = await transformManuscript(entry, { ...config, rootUrl });
        if (!html) {
          transformCache.delete(entry.target);
          return;
        }
        const etag = `W/"${Date.now()}"`;
        if (entry.source?.type === "file") {
          server?.watcher.add(entry.source.pathname);
        }
        return { content: html, etag };
      } catch (error) {
        server?.config.logger.error(getFormattedError(error));
        transformCache.delete(entry.target);
        return;
      }
    })();
    transformCache.set(entry.target, promise);
    return await promise;
  }
  async function transformAll(host) {
    const tocEntries = [];
    for (const entry of config.entries) {
      if (entry.rel === "contents") {
        tocEntries.push(entry);
        continue;
      }
      await transform(entry, host);
    }
    for (const entry of tocEntries) {
      await transform(entry, host);
    }
  }
  async function invalidate(entry) {
    const cwd2 = pathToFileURL6(config.workspaceDir);
    const target = pathToFileURL6(entry.target);
    if (target.href.indexOf(cwd2.href) !== 0) {
      return;
    }
    transformCache.delete(entry.target);
    config.entries.filter((entry2) => entry2.rel === "contents").forEach((entry2) => {
      transformCache.delete(entry2.target);
    });
    server?.ws.send({
      type: "full-reload",
      path: target.href.slice(cwd2.href.length)
    });
  }
  const devServerMiddleware = async function vivliostyleDevServerMiddleware(req, res, next) {
    if (!program) {
      return next();
    }
    const { entriesLookup, urlMatchRe } = program;
    const [_, pathname, qs] = decodeURI(req.url).match(urlMatchRe) ?? [];
    const match = pathname && entriesLookup(pathname);
    if (!match) {
      return next();
    }
    const [entry, expected] = match;
    if (pathname !== expected) {
      res.statusCode = 301;
      res.setHeader("Location", `${expected}${qs || ""}`);
      return res.end();
    }
    Logger.debug("dev-server > request %s", pathname);
    const cachePromise = transformCache.get(entry.target);
    if (cachePromise) {
      const cached = await cachePromise;
      if (!cached) {
        return next();
      }
      if (req.headers["if-none-match"] === cached.etag) {
        res.statusCode = 304;
        return res.end();
      } else {
        res.statusCode = 200;
        res.setHeader("Content-Type", "text/html;charset=utf-8");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Etag", cached.etag);
        return res.end(cached.content);
      }
    }
    const { host } = req.headers;
    if (entry.rel === "contents") {
      await transformAll(host);
    }
    const result = await transform(entry, host);
    if (!result) {
      return next();
    }
    res.statusCode = 200;
    res.setHeader("Content-Type", "text/html;charset=utf-8");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Etag", result.etag);
    return res.end(result.content);
  };
  const serveWorkspaceMiddleware = async function vivliostyleServeWorkspaceMiddleware(req, res, next) {
    if (!config || !program) {
      return next();
    }
    const {
      urlMatchRe,
      serveWorkspace,
      serveWorkspaceMatcher,
      serveAssets,
      serveAssetsMatcher
    } = program;
    const [_, pathname] = decodeURI(req.url).match(urlMatchRe) ?? [];
    if (!pathname) {
      return next();
    }
    const handleWorkspace = (next2) => {
      if (!serveWorkspaceMatcher.match(pathname.slice(1))) {
        return next2();
      }
      Logger.debug("dev-server > serveWorkspace %s", pathname);
      const url = req.url;
      req.url = req.url.slice(config.base.length);
      return serveWorkspace(req, res, () => {
        req.url = url;
        next2();
      });
    };
    const handleAssets = (next2) => {
      if (!serveAssetsMatcher.match(pathname.slice(1))) {
        return next2();
      }
      Logger.debug("dev-server > serveAssets %s", pathname);
      const url = req.url;
      req.url = url.slice(config.base.length);
      return serveAssets(req, res, () => {
        req.url = url;
        next2();
      });
    };
    handleWorkspace(() => handleAssets(next));
  };
  return {
    name: "vivliostyle:dev-server",
    enforce: "pre",
    configureServer(viteServer) {
      server = viteServer;
      const requestReload = debounce(async () => {
        await reload();
        viteServer.ws.send({
          type: "full-reload",
          path: "*"
        });
      }, 200);
      const handleUpdate = (pathname) => {
        if (!matchProjectDep?.(pathname)) {
          return;
        }
        requestReload();
      };
      viteServer.watcher.on("add", handleUpdate);
      viteServer.watcher.on("change", handleUpdate);
      viteServer.watcher.on("unlink", handleUpdate);
      return () => {
        viteServer.middlewares.use(devServerMiddleware);
        viteServer.middlewares.use(serveWorkspaceMiddleware);
      };
    },
    configurePreviewServer(viteServer) {
      return () => {
        viteServer.middlewares.use(
          config.base,
          sirv(config.workspaceDir, { dev: true, etag: false, extensions: [] })
        );
      };
    },
    async buildStart() {
      await reload(true);
      await transformAll(void 0);
    },
    async handleHotUpdate(ctx) {
      const entry = config?.entries.find(
        (e) => e.source?.type === "file" && e.source.pathname === ctx.file || !e.source && e.target === ctx.file
      );
      if (config && entry) {
        await invalidate(entry);
      }
    }
  };
}

// src/vite/vite-plugin-static-serve.ts
import sirv2 from "sirv";
import upath9 from "upath";
function vsStaticServePlugin({
  config: _config,
  inlineConfig
}) {
  let config = _config;
  const createMiddlewares = () => {
    if (typeof config.serverRootDir !== "string") {
      return [];
    }
    return Object.entries(config.static).flatMap(
      ([base, dirs]) => dirs.map(
        (dir) => [
          base,
          sirv2(upath9.resolve(config.serverRootDir, dir), {
            dev: true,
            etag: false
          })
        ]
      )
    );
  };
  return {
    name: "vivliostyle:static-serve",
    apply: () => Boolean(inlineConfig.enableStaticServe),
    configureServer(viteServer) {
      return () => {
        createMiddlewares().forEach(([base, middleware]) => {
          viteServer.middlewares.use(base, middleware);
        });
      };
    },
    configurePreviewServer(viteServer) {
      return () => {
        createMiddlewares().forEach(([base, middleware]) => {
          viteServer.middlewares.use(base, middleware);
        });
      };
    }
  };
}

// src/vite/vite-plugin-viewer.ts
import fs10 from "node:fs";
import sirv3 from "sirv";
import upath10 from "upath";
var viewerClientId = "@vivliostyle:viewer:client";
var viewerClientRequestPath = `/${viewerClientId}`;
var viewerClientContent = (
  /* js */
  `
if (import.meta.hot) {
  import.meta.hot.on('vite:beforeFullReload', (e) => {
    location.reload();
  });
}`
);
function vsViewerPlugin(_) {
  const serveRootDir = upath10.join(viewerRoot, "lib");
  const serve = sirv3(serveRootDir, { dev: false, etag: true });
  let cachedIndexHtml;
  const middleware = async function vivliostyleViewerMiddleware(req, res, next) {
    if (req.url === "/" || req.url === "/index.html") {
      cachedIndexHtml ??= prependToHead(
        fs10.readFileSync(upath10.join(serveRootDir, "index.html"), "utf-8"),
        `<script type="module" src="${viewerClientRequestPath}"></script>`
      );
      res.statusCode = 200;
      res.setHeader("Content-Type", "text/html;charset=utf-8");
      res.setHeader("Cache-Control", "no-cache");
      return res.end(cachedIndexHtml);
    } else {
      return serve(req, res, next);
    }
  };
  return {
    name: "vivliostyle:viewer",
    config() {
      return {
        optimizeDeps: {
          exclude: ["@vivliostyle/viewer"]
        }
      };
    },
    configureServer(viteServer) {
      viteServer.middlewares.use(VIEWER_ROOT_PATH, middleware);
    },
    configurePreviewServer(viteServer) {
      viteServer.middlewares.use(VIEWER_ROOT_PATH, serve);
    },
    load(id) {
      if (id === viewerClientRequestPath) {
        return viewerClientContent;
      }
    }
  };
}

// src/server.ts
function getViewerParams(src, {
  size,
  cropMarks,
  bleed,
  cropOffset,
  css,
  customStyle,
  customUserStyle,
  singleDoc,
  quick,
  viewerParam,
  base
}) {
  const pageSizeValue = size && ("format" in size ? size.format : `${size.width} ${size.height}`);
  function escapeParam(url) {
    return url.replace(/&/g, "%26");
  }
  let viewerParams = src ? `src=${escapeParam(src)}` : "";
  viewerParams += `&bookMode=${!singleDoc}&renderAllPages=${!quick}`;
  if (customStyle) {
    const param = isValidUri(customStyle) ? customStyle : upath11.posix.join(base, customStyle);
    viewerParams += `&style=${escapeParam(param)}`;
  }
  if (customUserStyle) {
    const param = isValidUri(customUserStyle) ? customUserStyle : upath11.posix.join(base, customUserStyle);
    viewerParams += `&userStyle=${escapeParam(param)}`;
  }
  if (pageSizeValue || cropMarks || bleed || cropOffset || css) {
    let pageStyle = "@page{";
    if (pageSizeValue) {
      pageStyle += `size:${pageSizeValue};`;
    }
    if (cropMarks) {
      pageStyle += `marks:crop cross;`;
    }
    if (bleed || cropMarks) {
      pageStyle += `bleed:${bleed ?? "3mm"};`;
    }
    if (cropOffset) {
      pageStyle += `crop-offset:${cropOffset};`;
    }
    pageStyle += "}";
    viewerParams += `&style=data:,/*<viewer>*/${encodeURIComponent(
      pageStyle
    )}/*</viewer>*/${encodeURIComponent(css ?? "")}`;
  }
  if (viewerParam) {
    viewerParams += `&${viewerParam}`;
  }
  return viewerParams;
}
async function getSourceUrl({
  viewerInput,
  base,
  workspaceDir,
  rootUrl
}) {
  let input;
  switch (viewerInput.type) {
    case "webpub":
      input = viewerInput.manifestPath;
      break;
    case "webbook":
      input = viewerInput.webbookEntryUrl;
      break;
    case "epub-opf":
      input = viewerInput.epubOpfPath;
      break;
    case "epub": {
      if (!fs11.existsSync(viewerInput.epubTmpOutputDir)) {
        await openEpub(viewerInput.epubPath, viewerInput.epubTmpOutputDir);
      }
      input = getDefaultEpubOpfPath(viewerInput.epubTmpOutputDir);
      break;
    }
    default:
      input = viewerInput;
  }
  return (isValidUri(input) ? new URL2(input) : new URL2(
    upath11.posix.join(base, upath11.relative(workspaceDir, input)),
    rootUrl
  )).href;
}
async function getViewerFullUrl({
  viewerInput,
  base,
  workspaceDir,
  rootUrl,
  viewer,
  ...config
}) {
  const viewerUrl = viewer ? new URL2(viewer) : new URL2(`${VIEWER_ROOT_PATH}/index.html`, rootUrl);
  const sourceUrl = await getSourceUrl({
    viewerInput,
    base,
    workspaceDir,
    rootUrl
  });
  const viewerParams = getViewerParams(
    sourceUrl === EMPTY_DATA_URI ? void 0 : sourceUrl,
    { base, ...config }
  );
  viewerUrl.hash = "";
  return `${viewerUrl.href}#${viewerParams}`;
}
async function createViteServer({
  config,
  viteConfig,
  inlineConfig,
  mode
}) {
  const viteInlineConfig = {
    clearScreen: false,
    configFile: false,
    appType: "custom",
    plugins: [
      vsDevServerPlugin({ config, inlineConfig }),
      vsViewerPlugin({ config, inlineConfig }),
      vsBrowserPlugin({ config, inlineConfig }),
      vsStaticServePlugin({ config, inlineConfig })
    ],
    server: viteConfig.server,
    preview: viteConfig.preview,
    customLogger: viteConfig.customLogger,
    cacheDir: viteConfig.cacheDir,
    root: viteConfig.root
  };
  Logger.debug("createViteServer > viteInlineConfig %O", viteInlineConfig);
  if (config.serverRootDir === config.workspaceDir) {
    const { cacheDir } = viteInlineConfig;
    registerExitHandler("Removing the Vite cacheDir", () => {
      if (fs11.existsSync(cacheDir)) {
        fs11.rmSync(cacheDir, { recursive: true });
      }
    });
  }
  if (mode === "preview") {
    return await createServer(viteInlineConfig);
  } else {
    return await preview(viteInlineConfig);
  }
}

// src/vite/vite-plugin-browser.ts
function vsBrowserPlugin({
  config: _config,
  inlineConfig
}) {
  let config = _config;
  let server;
  let closeBrowser;
  async function handlePageClose() {
    await server?.close();
    runExitHandlers();
  }
  async function openPreviewPage() {
    const url = await getViewerFullUrl(config);
    const { page, browser } = await launchPreview({
      mode: "preview",
      url,
      config,
      onPageOpen: async (page2) => {
        page2.on("close", handlePageClose);
        const locale = Intl.DateTimeFormat().resolvedOptions().locale;
        await page2.addInitScript(
          `window.localStorage.setItem('i18nextLng', '${locale}');`
        );
      }
    });
    await page.bringToFront();
    await page.locator("#vivliostyle-input-url").focus({ timeout: 0 });
    closeBrowser = () => {
      page.off("close", handlePageClose);
      browser.close();
    };
  }
  return {
    name: "vivliostyle:browser",
    apply: () => Boolean(inlineConfig.openViewer),
    configureServer(viteServer) {
      server = viteServer;
      const _listen = viteServer.listen;
      viteServer.listen = async (...args) => {
        const server2 = await _listen(...args);
        config = await reloadConfig(config, inlineConfig, server2.config);
        await openPreviewPage();
        return server2;
      };
    },
    closeBundle() {
      closeBrowser?.();
    }
  };
}

export {
  loadVivliostyleConfig,
  warnDeprecatedConfig,
  mergeConfig,
  mergeInlineConfig,
  isWebPubConfig,
  resolveTaskConfig,
  getFullBrowserName,
  launchPreview,
  vsBrowserPlugin,
  copyAssets,
  buildWebPublication,
  cleanupWorkspace,
  prepareThemeDirectory,
  compile,
  vsDevServerPlugin,
  vsStaticServePlugin,
  vsViewerPlugin,
  getSourceUrl,
  getViewerFullUrl,
  createViteServer
};
//# sourceMappingURL=chunk-WXPIB2DF.js.map