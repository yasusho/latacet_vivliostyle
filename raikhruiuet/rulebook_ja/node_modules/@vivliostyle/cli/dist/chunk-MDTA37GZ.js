import {
  VivliostyleInlineConfig
} from "./chunk-YUYXQJDY.js";
import {
  EMPTY_DATA_URI
} from "./chunk-4IIM6RSG.js";

// src/util.ts
import { codeFrameColumns } from "@babel/code-frame";
import {
  evaluate,
  parse
} from "@humanwhocodes/momoa";
import { Ajv } from "ajv";
import formatsPlugin from "ajv-formats";
import { XMLParser } from "fast-xml-parser";
import StreamZip from "node-stream-zip";
import fs from "node:fs";
import readline from "node:readline";
import util from "node:util";
import tmp from "tmp";
import upath from "upath";
import { gray, red, redBright as redBright2 } from "yoctocolors";

// src/logger.ts
import debug from "debug";
import yoctoSpinner from "yocto-spinner";
import { blueBright, greenBright, redBright, yellowBright } from "yoctocolors";
var isUnicodeSupported = process.platform !== "win32" || Boolean(process.env.WT_SESSION);
var randomBookSymbol = ["\u{1F4D5}", "\u{1F4D7}", "\u{1F4D8}", "\u{1F4D9}"][Math.floor(Math.random() * 4)];
var infoSymbol = blueBright("INFO");
var successSymbol = greenBright("SUCCESS");
var warnSymbol = yellowBright("WARN");
var errorSymbol = redBright("ERROR");
var Logger = class _Logger {
  /**
   * 0: silent 1: info 2: verbose 3: debug
   */
  static #logLevel = 0;
  static #loggerInstance;
  static #nonBlockingLogPrinted = false;
  static #customLogger;
  static #logPrefix;
  static debug = debug("vs-cli");
  static get #spinner() {
    return this.#loggerInstance && this.#loggerInstance.#_spinner;
  }
  static get isInteractive() {
    return Boolean(
      !this.#customLogger && process.stderr.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env) && !import.meta.env?.VITEST && !debug.enabled("vs-cli") && // Prevent stream output in docker container so that not to spawn process
      !isInContainer()
    );
  }
  static startLogging(text) {
    if (this.#logLevel === 0) {
      return;
    }
    if (!this.isInteractive) {
      this.logInfo(text);
      return;
    }
    if (this.#loggerInstance) {
      this.#loggerInstance.#_spinner.text = text;
      return this.#loggerInstance;
    }
    this.#loggerInstance = new _Logger();
    this.#loggerInstance.#start(text);
    return this.#loggerInstance;
  }
  static suspendLogging(text) {
    if (this.#logLevel === 0) {
      return;
    }
    if (!this.#spinner || !this.isInteractive) {
      this.logInfo(text);
      return;
    }
    const currentMsg = this.#spinner?.text;
    this.logUpdate(currentMsg);
    this.#spinner.stop(`${infoSymbol} ${text}
`);
    return {
      [Symbol.dispose]() {
        if (_Logger.isInteractive) {
          console.log("");
          _Logger.#spinner?.start(currentMsg);
          _Logger.#nonBlockingLogPrinted = true;
        }
      }
    };
  }
  static log(...messages) {
    if (this.#logLevel < 1) {
      return;
    }
    console.log(...messages);
  }
  static logUpdate(...messages) {
    if (!this.#spinner || !this.isInteractive) {
      this.logInfo(...messages);
      return;
    }
    this.#spinner.stop(
      this.#nonBlockingLogPrinted ? void 0 : `${infoSymbol} ${this.#spinner.text}`
    );
    this.#spinner.start(messages.join(" "));
    this.#nonBlockingLogPrinted = false;
  }
  static getMessage(message, symbol) {
    return !this.#customLogger && symbol ? `${symbol} ${message}` : message;
  }
  static #nonBlockingLog(logMethod, message) {
    if (!this.#spinner || !this.isInteractive) {
      if (this.#logPrefix) {
        message = `${this.#logPrefix} ${message}`;
      }
      this.#logLevel >= 3 ? this.debug(message) : (this.#customLogger || console)[logMethod](message);
      return;
    }
    this.logUpdate(this.#spinner.text);
    this.#nonBlockingLogPrinted = true;
    this.#spinner.stop(message);
    this.#spinner.start();
  }
  static logSuccess(...messages) {
    if (this.#logLevel < 1) {
      return;
    }
    this.#nonBlockingLog(
      "info",
      this.getMessage(messages.join(" "), successSymbol)
    );
  }
  static logError(...messages) {
    if (this.#logLevel < 1) {
      return;
    }
    this.#nonBlockingLog(
      "error",
      this.getMessage(messages.join(" "), errorSymbol)
    );
  }
  static logWarn(...messages) {
    if (this.#logLevel < 1) {
      return;
    }
    this.#nonBlockingLog(
      "warn",
      this.getMessage(messages.join(" "), warnSymbol)
    );
  }
  static logInfo(...messages) {
    if (this.#logLevel < 1) {
      return;
    }
    this.#nonBlockingLog(
      "info",
      this.getMessage(messages.join(" "), infoSymbol)
    );
  }
  static logVerbose(...messages) {
    if (this.#logLevel < 2) {
      return;
    }
    this.#nonBlockingLog("info", this.getMessage(messages.join(" ")));
  }
  static setLogLevel(level) {
    if (!level) {
      return;
    }
    this.#logLevel = {
      silent: 0,
      info: 1,
      verbose: 2,
      debug: 3
    }[level];
    if (this.#logLevel >= 3) {
      debug.enable("vs-cli");
    }
  }
  static setCustomLogger(logger) {
    this.#customLogger = logger;
  }
  static setLogPrefix(prefix) {
    this.#logPrefix = prefix;
  }
  #_spinner;
  #_disposeSpinnerExitHandler;
  constructor() {
    this.#_spinner = yoctoSpinner({
      spinner: {
        frames: isUnicodeSupported ? ["\u2581\u2581\u2571 ", "\u2581\u2551\u2581 ", "\u2572\u2581\u2581 ", "\u2581\u2581\u2581 ", "\u2581\u2581\u2581 ", "\u2581\u2581\u2581 "] : ["-   ", "\\   ", "|   ", "/   "],
        interval: 80
      },
      color: "gray"
    });
    return this;
  }
  #start(text) {
    this.#_spinner.start(text);
    this.#_disposeSpinnerExitHandler = registerExitHandler(
      "Stopping spinner",
      () => {
        this.#_spinner.stop();
      }
    );
  }
  [Symbol.dispose]() {
    this.#_disposeSpinnerExitHandler?.();
    this.#_spinner.stop(
      _Logger.#nonBlockingLogPrinted ? void 0 : `${infoSymbol} ${this.#_spinner.text}`
    );
    _Logger.#loggerInstance = void 0;
  }
};

// schemas/pub-manifest/module/bcp.schema.json
var bcp_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/bcp.schema.json",
  title: "BCP47 Language tag",
  type: "string",
  pattern: "^((?:(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?:([A-Za-z]{2,3}(-(?:[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?:[A-Za-z]{4}))?(-(?:[A-Za-z]{2}|[0-9]{3}))?(-(?:[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?:[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?:x(-[A-Za-z0-9]{1,8})+))?)|(?:x(-[A-Za-z0-9]{1,8})+))$"
};

// schemas/pub-manifest/module/context.schema.json
var context_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/context.schema.json",
  title: "Publication Contexts",
  type: "array",
  items: [
    {
      const: "https://schema.org"
    },
    {
      const: "https://www.w3.org/ns/pub-context"
    }
  ],
  additionalItems: {
    anyOf: [
      {
        type: "string"
      },
      {
        type: "object",
        properties: {
          language: {
            $ref: "bcp.schema.json"
          },
          direction: false
        },
        required: ["language"]
      },
      {
        type: "object",
        properties: {
          direction: {
            type: "string",
            enum: ["ltr", "rtl"]
          },
          language: false
        },
        required: ["direction"]
      },
      {
        type: "object",
        properties: {
          language: {
            $ref: "bcp.schema.json"
          },
          direction: {
            type: "string",
            enum: ["ltr", "rtl"]
          }
        },
        required: ["language", "direction"]
      },
      {
        type: "object",
        properties: {
          language: false,
          direction: false
        }
      }
    ]
  }
};

// schemas/pub-manifest/module/contributor-object.schema.json
var contributor_object_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/contributor-object.schema.json",
  title: "Contributor Object",
  type: "object",
  properties: {
    name: {
      $ref: "localizable.schema.json"
    },
    id: {
      $ref: "url.schema.json"
    },
    type: {
      oneOf: [
        {
          type: "string",
          enum: ["Person", "Organization"],
          default: "Person"
        },
        {
          type: "array",
          items: {
            type: "string"
          },
          contains: {
            enum: ["Person", "Organization"]
          }
        }
      ]
    },
    url: {
      $ref: "url.schema.json"
    },
    identifier: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  required: ["name"]
};

// schemas/pub-manifest/module/contributor.schema.json
var contributor_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/contributor.schema.json",
  title: "Contributor",
  anyOf: [
    {
      type: "string"
    },
    {
      type: "array",
      items: {
        anyOf: [
          {
            type: "string"
          },
          {
            $ref: "contributor-object.schema.json"
          }
        ]
      }
    },
    {
      $ref: "contributor-object.schema.json"
    }
  ]
};

// schemas/pub-manifest/module/date.schema.json
var date_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/date.schema.json",
  title: "Dates",
  type: "string",
  format: "date-time"
};

// schemas/pub-manifest/module/duration.schema.json
var duration_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/duration.schema.json",
  title: "Duration",
  type: "string",
  pattern: "^P(?!$)((\\d+Y)|(\\d+\\.\\d+Y$))?((\\d+M)|(\\d+\\.\\d+M$))?((\\d+W)|(\\d+\\.\\d+W$))?((\\d+D)|(\\d+\\.\\d+D$))?(T(?=\\d)((\\d+H)|(\\d+\\.\\d+H$))?((\\d+M)|(\\d+\\.\\d+M$))?(\\d+(\\.\\d+)?S)?)??$"
};

// schemas/pub-manifest/module/item-lists.schema.json
var item_lists_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/item-lists.schema.json",
  title: "Lists of ItemList",
  oneOf: [
    {
      $ref: "ItemList.schema.json"
    },
    {
      type: "array",
      items: {
        $ref: "ItemList.schema.json"
      }
    }
  ]
};

// schemas/pub-manifest/module/ItemList.schema.json
var ItemList_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/ItemList.schema.json",
  title: "schema.org ItemList object",
  type: "object",
  properties: {
    type: {
      oneOf: [
        {
          type: "string",
          const: "ItemList"
        },
        {
          type: "array",
          items: {
            type: "string"
          },
          contains: {
            const: "ItemList"
          }
        }
      ]
    },
    itemListElement: {
      type: ["array"],
      items: {
        type: "string"
      }
    }
  },
  required: ["type", "itemListElement"]
};

// schemas/pub-manifest/module/language.schema.json
var language_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/language.schema.json",
  title: "Languages",
  oneOf: [
    {
      $ref: "bcp.schema.json"
    },
    {
      type: "array",
      items: {
        $ref: "bcp.schema.json"
      }
    }
  ]
};

// schemas/pub-manifest/module/link.schema.json
var link_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/link.schema.json",
  title: "Publication Links",
  type: "object",
  properties: {
    type: {
      oneOf: [
        {
          type: "string",
          const: "LinkedResource"
        },
        {
          type: "array",
          items: {
            type: "string"
          },
          contains: {
            const: "LinkedResource"
          }
        }
      ]
    },
    url: {
      $ref: "url.schema.json"
    },
    encodingFormat: {
      type: "string"
    },
    name: {
      $ref: "localizable.schema.json"
    },
    description: {
      anyOf: [
        {
          type: "string"
        },
        {
          $ref: "localizable-object.schema.json"
        }
      ]
    },
    rel: {
      type: ["string", "array"],
      items: {
        type: "string"
      }
    },
    integrity: {
      type: "string"
    },
    duration: {
      $ref: "duration.schema.json"
    },
    alternate: {
      $ref: "resource.categorization.schema.json"
    }
  },
  required: ["url"]
};

// schemas/pub-manifest/module/localizable-object.schema.json
var localizable_object_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/localizable-object.schema.json",
  title: "Localizable String Object",
  type: "object",
  properties: {
    value: {
      type: "string"
    },
    language: {
      $ref: "bcp.schema.json"
    }
  },
  required: ["value"]
};

// schemas/pub-manifest/module/localizable.schema.json
var localizable_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/localizable.schema.json",
  title: "Localizable String or Object",
  anyOf: [
    {
      type: "string"
    },
    {
      type: "array",
      items: {
        anyOf: [
          {
            type: "string"
          },
          {
            $ref: "localizable-object.schema.json"
          }
        ]
      }
    },
    {
      $ref: "localizable-object.schema.json"
    }
  ]
};

// schemas/pub-manifest/module/resource.categorization.schema.json
var resource_categorization_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/resource.categorization.schema.json",
  title: "Resource Categorization",
  oneOf: [
    {
      oneOf: [
        {
          $ref: "url.schema.json"
        },
        {
          $ref: "link.schema.json"
        }
      ]
    },
    {
      type: "array",
      items: {
        anyOf: [
          {
            $ref: "url.schema.json"
          },
          {
            $ref: "link.schema.json"
          }
        ]
      },
      uniqueItems: true
    }
  ]
};

// schemas/pub-manifest/module/strings.schema.json
var strings_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/strings.schema.json",
  title: "Unique strings",
  type: ["string", "array"],
  items: {
    type: "string"
  }
};

// schemas/pub-manifest/module/url.schema.json
var url_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/url.schema.json",
  title: "URL",
  type: "string",
  format: "uri-reference"
};

// schemas/pub-manifest/module/urls.schema.json
var urls_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/module/urls.schema.json",
  title: "URLs",
  oneOf: [
    {
      type: "string",
      format: "uri-reference"
    },
    {
      type: "array",
      items: {
        type: "string",
        format: "uri-reference"
      }
    }
  ]
};

// schemas/pub-manifest/publication.schema.json
var publication_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://www.w3.org/ns/pub-schema/manifest/publication.schema.json",
  title: "Publication Manifest",
  type: "object",
  properties: {
    "@context": {
      $ref: "module/context.schema.json"
    },
    type: {
      type: ["string", "array"],
      items: {
        type: "string"
      }
    },
    conformsTo: {
      oneOf: [
        {
          $ref: "module/url.schema.json"
        },
        {
          type: "array",
          items: {
            $ref: "module/url.schema.json"
          }
        }
      ]
    },
    id: {
      type: "string"
    },
    abridged: {
      type: "boolean"
    },
    accessMode: {
      $ref: "module/strings.schema.json"
    },
    accessModeSufficient: {
      $ref: "module/item-lists.schema.json"
    },
    accessibilityFeature: {
      $ref: "module/strings.schema.json"
    },
    accessibilityHazard: {
      $ref: "module/strings.schema.json"
    },
    accessibilitySummary: {
      $ref: "module/localizable.schema.json"
    },
    artist: {
      $ref: "module/contributor.schema.json"
    },
    author: {
      $ref: "module/contributor.schema.json"
    },
    colorist: {
      $ref: "module/contributor.schema.json"
    },
    contributor: {
      $ref: "module/contributor.schema.json"
    },
    creator: {
      $ref: "module/contributor.schema.json"
    },
    editor: {
      $ref: "module/contributor.schema.json"
    },
    illustrator: {
      $ref: "module/contributor.schema.json"
    },
    inker: {
      $ref: "module/contributor.schema.json"
    },
    letterer: {
      $ref: "module/contributor.schema.json"
    },
    penciler: {
      $ref: "module/contributor.schema.json"
    },
    publisher: {
      $ref: "module/contributor.schema.json"
    },
    readBy: {
      $ref: "module/contributor.schema.json"
    },
    translator: {
      $ref: "module/contributor.schema.json"
    },
    url: {
      $ref: "module/urls.schema.json"
    },
    duration: {
      $ref: "module/duration.schema.json"
    },
    inLanguage: {
      $ref: "module/language.schema.json"
    },
    dateModified: {
      $ref: "module/date.schema.json"
    },
    datePublished: {
      $ref: "module/date.schema.json"
    },
    name: {
      $ref: "module/localizable.schema.json"
    },
    readingOrder: {
      $ref: "module/resource.categorization.schema.json"
    },
    resources: {
      $ref: "module/resource.categorization.schema.json"
    },
    links: {
      $ref: "module/resource.categorization.schema.json"
    },
    readingProgression: {
      type: "string",
      enum: ["ltr", "rtl"],
      default: "ltr"
    }
  },
  required: ["@context", "conformsTo"]
};

// src/schema/pub-manifest.ts
var publicationSchemas = [
  bcp_schema_default,
  context_schema_default,
  contributor_object_schema_default,
  contributor_schema_default,
  date_schema_default,
  duration_schema_default,
  item_lists_schema_default,
  ItemList_schema_default,
  language_schema_default,
  link_schema_default,
  localizable_object_schema_default,
  localizable_schema_default,
  resource_categorization_schema_default,
  strings_schema_default,
  url_schema_default,
  urls_schema_default,
  publication_schema_default
];

// src/util.ts
var cwd = upath.normalize(process.cwd());
var beforeExitHandlers = [];
var registerExitHandler = (debugMessage, handler) => {
  const callback = () => {
    Logger.debug(debugMessage);
    handler();
  };
  beforeExitHandlers.push(callback);
  return () => {
    const index = beforeExitHandlers.indexOf(callback);
    if (index !== -1) {
      beforeExitHandlers.splice(index, 1);
    }
  };
};
function runExitHandlers() {
  while (beforeExitHandlers.length) {
    try {
      beforeExitHandlers.shift()?.();
    } catch (e) {
    }
  }
}
var exitSignals = ["exit", "SIGINT", "SIGTERM"];
exitSignals.forEach((sig) => {
  process.once(sig, (signal, exitCode) => {
    runExitHandlers();
    if (process.exitCode === void 0) {
      process.exitCode = exitCode !== void 0 ? 128 + exitCode : Number(signal);
    }
    process.exit();
  });
});
if (process.platform === "win32") {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  rl.on("SIGINT", () => {
    runExitHandlers();
    process.exit(1);
  });
  registerExitHandler("Closing readline interface", () => {
    rl.close();
  });
}
var DetailError = class extends Error {
  constructor(message, detail) {
    super(message);
    this.detail = detail;
  }
};
function getFormattedError(err) {
  return err instanceof DetailError ? `${err.message}
${err.detail}` : err.stack || `${err.message}`;
}
function gracefulError(err) {
  console.log(`${redBright2("ERROR")} ${getFormattedError(err)}

${gray("If you think this is a bug, please report at https://github.com/vivliostyle/vivliostyle-cli/issues")}`);
  process.exit(1);
}
function readJSON(path) {
  try {
    return JSON.parse(fs.readFileSync(path, "utf8"));
  } catch (err) {
    return void 0;
  }
}
function statFileSync(filePath, {
  errorMessage = "Specified input does not exist"
} = {}) {
  try {
    return fs.statSync(filePath);
  } catch (err) {
    if (err.code === "ENOENT") {
      throw new Error(`${errorMessage}: ${filePath}`);
    }
    throw err;
  }
}
async function inflateZip(filePath, dest) {
  return await new Promise((res, rej) => {
    try {
      const zip = new StreamZip({
        file: filePath,
        storeEntries: true
      });
      zip.on("error", (err) => {
        rej(err);
      });
      zip.on("ready", async () => {
        await util.promisify(zip.extract)(null, dest);
        await util.promisify(zip.close)();
        Logger.debug(`Unzipped ${filePath} to ${dest}`);
        res();
      });
    } catch (err) {
      rej(err);
    }
  });
}
function useTmpDirectory() {
  return new Promise((res, rej) => {
    tmp.dir({ unsafeCleanup: true }, (err, path, clear) => {
      if (err) {
        return rej(err);
      }
      Logger.debug(`Created the temporary directory: ${path}`);
      if (import.meta.env?.VITEST) {
        return res([path, () => {
        }]);
      }
      const callback = () => {
        fs.rmSync(path, { force: true, recursive: true });
      };
      registerExitHandler(
        `Removing the temporary directory: ${path}`,
        callback
      );
      res([path, callback]);
    });
  });
}
function touchTmpFile(path) {
  fs.mkdirSync(upath.dirname(path), { recursive: true });
  fs.closeSync(fs.openSync(path, "a"));
  Logger.debug(`Created the temporary file: ${path}`);
  const callback = () => {
    fs.rmSync(path, { force: true, recursive: true });
  };
  registerExitHandler(`Removing the temporary file: ${path}`, callback);
  return callback;
}
function pathEquals(path1, path2) {
  return upath.relative(path1, path2) === "";
}
function pathContains(parentPath, childPath) {
  const rel = upath.relative(parentPath, childPath);
  return rel !== "" && !rel.startsWith("..");
}
function isValidUri(str) {
  return /^(https?|file|data):/i.test(str);
}
function isInContainer() {
  return fs.existsSync("/opt/vivliostyle-cli/.vs-cli-version");
}
function isRunningOnWSL() {
  return fs.existsSync("/proc/version") && fs.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft");
}
async function openEpub(epubPath, tmpDir) {
  await inflateZip(epubPath, tmpDir);
  Logger.debug(`Created the temporary EPUB directory: ${tmpDir}`);
  const deleteEpub = () => {
    fs.rmSync(tmpDir, { force: true, recursive: true });
  };
  registerExitHandler(
    `Removing the temporary EPUB directory: ${tmpDir}`,
    deleteEpub
  );
  return deleteEpub;
}
function getDefaultEpubOpfPath(epubDir) {
  const containerXmlPath = upath.join(epubDir, "META-INF/container.xml");
  const xmlParser = new XMLParser({
    ignoreAttributes: false
  });
  const { container } = xmlParser.parse(
    fs.readFileSync(containerXmlPath, "utf8")
  );
  const rootfile = [container.rootfiles.rootfile].flat()[0];
  const epubOpfPath = upath.join(epubDir, rootfile["@_full-path"]);
  return epubOpfPath;
}
function getEpubRootDir(epubOpfPath) {
  function traverse(dir) {
    const files = fs.readdirSync(dir);
    if (files.includes("META-INF") && pathEquals(epubOpfPath, getDefaultEpubOpfPath(dir))) {
      return dir;
    }
    const next = upath.dirname(dir);
    if (pathEquals(dir, next)) {
      return;
    }
    return traverse(next);
  }
  return traverse(upath.dirname(epubOpfPath));
}
var getAjvValidatorFunction = (schema, refSchemas) => (obj) => {
  const ajv = new Ajv({ strict: false });
  const addFormats = formatsPlugin;
  addFormats(ajv);
  if (refSchemas) {
    ajv.addSchema(refSchemas);
  }
  const validate = ajv.compile(schema);
  const valid = validate(obj);
  if (!valid) {
    throw validate.errors?.[0] || new Error();
  }
  return true;
};
var assertPubManifestSchema = getAjvValidatorFunction(
  publication_schema_default,
  publicationSchemas
);
function parseJsonc(rawJsonc) {
  const ast = parse(rawJsonc, {
    mode: "jsonc",
    ranges: false,
    tokens: false
  });
  return evaluate(ast);
}
function prettifySchemaError(rawJsonc, issues) {
  const parsed = parse(rawJsonc, {
    mode: "jsonc",
    ranges: false,
    tokens: false
  });
  function traverse(issues2, depth) {
    return issues2.flatMap((issue) => {
      const p = issue.path?.length || 0;
      if (!issue.issues) {
        return [[[issue], depth + p]];
      }
      return traverse(issue.issues, depth + p).map(([i, d]) => [
        [issue, ...i],
        d
      ]);
    });
  }
  const all = traverse(issues, 0);
  const maxDepth = Math.max(...all.map(([, d]) => d));
  const issuesTraversed = all.find(([, d]) => d === maxDepth)[0];
  let jsonValue = parsed.body;
  for (const p of issuesTraversed.flatMap((v2) => v2.path ?? [])) {
    let childValue;
    if (p.type === "object" && jsonValue.type === "Object") {
      childValue = jsonValue.members.find(
        (m) => m.name.type === "Identifier" && m.name.name === p.key || m.name.type === "String" && m.name.value === p.key
      )?.value;
    }
    if (p.type === "array" && jsonValue.type === "Array") {
      childValue = jsonValue.elements[p.key]?.value;
    }
    if (childValue) {
      jsonValue = childValue;
    } else {
      break;
    }
  }
  let message = `${red(issuesTraversed.at(-1).message)}`;
  if (jsonValue) {
    message += `
${codeFrameColumns(rawJsonc, jsonValue.loc, {
      highlightCode: true
    })}`;
  }
  return message;
}
function writeFileIfChanged(filePath, content) {
  if (!fs.existsSync(filePath) || !fs.readFileSync(filePath).equals(content)) {
    fs.mkdirSync(upath.dirname(filePath), { recursive: true });
    fs.writeFileSync(filePath, content);
  }
}
function debounce(func, wait, options = {}) {
  const leading = options.leading ?? false;
  const trailing = options.trailing ?? !leading;
  let timer = null;
  let pending = false;
  const invoke = (...args) => {
    pending = false;
    func(...args);
  };
  return (...args) => {
    pending = true;
    if (timer) {
      clearTimeout(timer);
    }
    const callNow = leading && !timer;
    timer = setTimeout(() => {
      const shouldCall = trailing && pending && !(leading && callNow);
      timer = null;
      if (shouldCall) {
        invoke(...args);
      } else {
        pending = false;
      }
    }, wait);
    if (callNow) {
      invoke(...args);
    }
  };
}

// src/commands/cli-flags.ts
import upath2 from "upath";
import * as v from "valibot";
function parseFlagsToInlineConfig(argv, setupProgram) {
  const program = setupProgram();
  program.parse(argv);
  let options = program.opts();
  const input = program.args?.[0];
  options = warnDeprecatedFlags(options);
  let inlineConfig = { input, ...options };
  if (input && !options.config && upath2.basename(input).startsWith("vivliostyle.config")) {
    inlineConfig = { config: input, ...options };
  }
  return v.parse(VivliostyleInlineConfig, inlineConfig);
}
function setupConfigFromFlags(flags) {
  if (!flags.input) {
    if (flags.enableViewerStartPage) {
      return {
        tasks: [{ entry: [] }],
        inlineOptions: {
          input: { format: "webbook", entry: EMPTY_DATA_URI }
        }
      };
    } else {
      throw new Error(
        "No input is set. Please set an appropriate entry or a Vivliostyle config file."
      );
    }
  }
  return {
    tasks: [{ entry: [] }],
    inlineOptions: { ...flags }
  };
}
function warnDeprecatedFlags(options) {
  const modifiedOptions = { ...options };
  if (options.executableChromium) {
    Logger.logWarn(
      "'--executable-chromium' option was deprecated and will be removed in a future release. Please replace with '--executable-browser' option."
    );
    modifiedOptions.executableBrowser = options.executableChromium;
  }
  if (options.verbose) {
    Logger.logWarn(
      "'--verbose' option was deprecated and will be removed in a future release. Please replace with '--log-level verbose' option."
    );
    modifiedOptions.logLevel = "verbose";
  }
  if (options.sandbox === false) {
    Logger.logWarn(
      "'--no-sandbox' option was deprecated and will be removed in a future release. It is no longer necessary because the sandbox is disabled by default."
    );
  }
  if (options.http) {
    Logger.logWarn(
      "'--http' option was deprecated and will be removed in a future release. It is unnecessary because the HTTP server starts automatically."
    );
  }
  return modifiedOptions;
}

export {
  cwd,
  registerExitHandler,
  runExitHandlers,
  DetailError,
  getFormattedError,
  gracefulError,
  readJSON,
  statFileSync,
  useTmpDirectory,
  touchTmpFile,
  pathEquals,
  pathContains,
  isValidUri,
  isInContainer,
  isRunningOnWSL,
  openEpub,
  getDefaultEpubOpfPath,
  getEpubRootDir,
  assertPubManifestSchema,
  parseJsonc,
  prettifySchemaError,
  writeFileIfChanged,
  debounce,
  isUnicodeSupported,
  randomBookSymbol,
  Logger,
  parseFlagsToInlineConfig,
  setupConfigFromFlags
};
//# sourceMappingURL=chunk-MDTA37GZ.js.map