import * as vite from 'vite';
import { StringifyMarkdownOptions, Metadata } from '@vivliostyle/vfm';
import { Processor } from 'unified';
import * as v from 'valibot';

interface LoggerInterface {
    info(message: string): void;
    warn(message: string): void;
    error(message: string): void;
}

/**
 * @see https://github.com/vivliostyle/vivliostyle-cli/blob/main/docs/config.md
 */
type StructuredDocument = {
    title: string;
    href: string;
    children: StructuredDocument[];
    sections?: StructuredDocumentSection[];
};
/** @hidden */
declare const StructuredDocument: v.GenericSchema<StructuredDocument>;
/**
 * @see https://github.com/vivliostyle/vivliostyle-cli/blob/main/docs/config.md
 */
type StructuredDocumentSection = {
    headingHtml: string;
    headingText: string;
    level: number;
    children: StructuredDocumentSection[];
    href?: string;
    id?: string;
};
/** @hidden */
declare const StructuredDocumentSection: v.GenericSchema<StructuredDocumentSection>;
declare const ValidString: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
declare const ThemeConfig: v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
    };
    readonly '~standard': v.StandardProps<{
        specifier: string;
    }, {
        specifier: string;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        specifier: string;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
    readonly '~types'?: {
        readonly input: {
            specifier: string;
        };
        readonly output: {
            specifier: string;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        import?: string | string[] | undefined;
    }, {
        import?: string[] | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        import?: string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
    readonly '~types'?: {
        readonly input: {
            import?: string | string[] | undefined;
        };
        readonly output: {
            import?: string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
    } | undefined;
}], undefined>, v.TitleAction<{
    specifier: string;
} & {
    import?: string[] | undefined;
}, "ThemeConfig">]>;
type ThemeConfig = v.InferInput<typeof ThemeConfig>;
declare const ThemeSpecifier: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
    };
    readonly '~standard': v.StandardProps<{
        specifier: string;
    }, {
        specifier: string;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        specifier: string;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
    readonly '~types'?: {
        readonly input: {
            specifier: string;
        };
        readonly output: {
            specifier: string;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        import?: string | string[] | undefined;
    }, {
        import?: string[] | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        import?: string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
    readonly '~types'?: {
        readonly input: {
            import?: string | string[] | undefined;
        };
        readonly output: {
            import?: string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
    } | undefined;
}], undefined>, v.TitleAction<{
    specifier: string;
} & {
    import?: string[] | undefined;
}, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
    };
    readonly '~standard': v.StandardProps<{
        specifier: string;
    }, {
        specifier: string;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        specifier: string;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
    readonly '~types'?: {
        readonly input: {
            specifier: string;
        };
        readonly output: {
            specifier: string;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        import?: string | string[] | undefined;
    }, {
        import?: string[] | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        import?: string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
    readonly '~types'?: {
        readonly input: {
            import?: string | string[] | undefined;
        };
        readonly output: {
            import?: string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
    } | undefined;
}], undefined>, v.TitleAction<{
    specifier: string;
} & {
    import?: string[] | undefined;
}, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
    specifier: string;
} & {
    import?: string[] | undefined;
}) | (string | ({
    specifier: string;
} & {
    import?: string[] | undefined;
}))[], ({
    specifier: string;
} & {
    import?: string[] | undefined;
})[]>]>;
type ThemeSpecifier = v.InferInput<typeof ThemeSpecifier>;
declare const ArticleEntryConfig: v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
    readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
    readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }))[], ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[]>]>, undefined>;
    readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    }, {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
    readonly '~types'?: {
        readonly input: {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        };
        readonly output: {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
    } | undefined;
}, v.TitleAction<{
    path: string;
    output?: string | undefined;
    title?: string | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    encodingFormat?: string | undefined;
    rel?: string[] | undefined;
}, "ArticleEntryConfig">]>;
type ArticleEntryConfig = v.InferInput<typeof ArticleEntryConfig>;
declare const ContentsEntryConfig: v.SchemaWithPipe<readonly [v.ObjectSchema<{
    readonly rel: v.LiteralSchema<"contents", undefined>;
    readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }))[], ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[]>]>, undefined>;
    readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
    readonly pageCounterReset: v.SchemaWithPipe<readonly [v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, undefined>, v.DescriptionAction<number | undefined, string>]>;
}, undefined>, v.TitleAction<{
    rel: "contents";
    path?: string | undefined;
    output?: string | undefined;
    title?: string | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    pageCounterReset?: number | undefined;
}, "ContentsEntryConfig">]>;
type ContentsEntryConfig = v.InferInput<typeof ContentsEntryConfig>;
declare const CoverEntryConfig: v.SchemaWithPipe<readonly [v.ObjectSchema<{
    readonly rel: v.LiteralSchema<"cover", undefined>;
    readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }))[], ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[]>]>, undefined>;
    readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
}, undefined>, v.TitleAction<{
    rel: "cover";
    path?: string | undefined;
    output?: string | undefined;
    title?: string | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    imageSrc?: string | undefined;
    imageAlt?: string | undefined;
    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
}, "CoverEntryConfig">]>;
type CoverEntryConfig = v.InferInput<typeof CoverEntryConfig>;
declare const EntryConfig: v.UnionSchema<[v.SchemaWithPipe<readonly [v.ObjectSchema<{
    readonly rel: v.LiteralSchema<"contents", undefined>;
    readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }))[], ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[]>]>, undefined>;
    readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
    readonly pageCounterReset: v.SchemaWithPipe<readonly [v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, undefined>, v.DescriptionAction<number | undefined, string>]>;
}, undefined>, v.TitleAction<{
    rel: "contents";
    path?: string | undefined;
    output?: string | undefined;
    title?: string | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    pageCounterReset?: number | undefined;
}, "ContentsEntryConfig">]>, v.SchemaWithPipe<readonly [v.ObjectSchema<{
    readonly rel: v.LiteralSchema<"cover", undefined>;
    readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }))[], ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[]>]>, undefined>;
    readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
}, undefined>, v.TitleAction<{
    rel: "cover";
    path?: string | undefined;
    output?: string | undefined;
    title?: string | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    imageSrc?: string | undefined;
    imageAlt?: string | undefined;
    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
}, "CoverEntryConfig">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
    readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
    readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }))[], ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[]>]>, undefined>;
    readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
    readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    }, {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
    readonly '~types'?: {
        readonly input: {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        };
        readonly output: {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
    } | undefined;
}, v.TitleAction<{
    path: string;
    output?: string | undefined;
    title?: string | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    encodingFormat?: string | undefined;
    rel?: string[] | undefined;
}, "ArticleEntryConfig">]>], undefined>;
type EntryConfig = v.InferInput<typeof EntryConfig>;
declare const OutputFormat: v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>;
type OutputFormat = v.InferInput<typeof OutputFormat>;
declare const RenderMode: v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>;
type RenderMode = v.InferInput<typeof RenderMode>;
declare const OutputConfig: v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
    };
    readonly '~standard': v.StandardProps<{
        path: string;
    }, {
        path: string;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        path: string;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
    readonly '~types'?: {
        readonly input: {
            path: string;
        };
        readonly output: {
            path: string;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
    readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
    readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
    readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
        readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
        readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
        readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
    readonly '~types'?: {
        readonly input: {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        };
        readonly output: {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
    } | undefined;
}], undefined>, v.TitleAction<{
    path: string;
} & {
    format?: "pdf" | "epub" | "webpub" | undefined;
    renderMode?: "local" | "docker" | undefined;
    preflight?: "press-ready" | "press-ready-local" | undefined;
    preflightOption?: string[] | undefined;
}, "OutputConfig">]>;
type OutputConfig = v.InferInput<typeof OutputConfig>;
declare const VfmReplaceRule: v.LooseObjectSchema<{
    readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
    readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
        readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
    }>]>;
}, undefined>;
type VfmReplaceRule = v.InferInput<typeof VfmReplaceRule>;
declare const BrowserType: v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>;
type BrowserType = v.InferInput<typeof BrowserType>;
declare const ReadingProgression: v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>;
type ReadingProgression = v.InferInput<typeof ReadingProgression>;
declare const LogLevel: v.UnionSchema<[v.LiteralSchema<"silent", undefined>, v.LiteralSchema<"info", undefined>, v.LiteralSchema<"verbose", undefined>, v.LiteralSchema<"debug", undefined>], undefined>;
type LogLevel = v.InferInput<typeof LogLevel>;
declare const CopyAssetConfig: v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
    readonly includes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
    readonly excludes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
    readonly includeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
    readonly excludeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly includes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
        readonly excludes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
        readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
        readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    }, {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>>;
    readonly '~types'?: {
        readonly input: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        };
        readonly output: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>;
    } | undefined;
}, v.TitleAction<{
    includes?: string[] | undefined;
    excludes?: string[] | undefined;
    includeFileExtensions?: string[] | undefined;
    excludeFileExtensions?: string[] | undefined;
}, "CopyAssetConfig">]>;
type CopyAssetConfig = v.InferInput<typeof CopyAssetConfig>;
declare const TocConfig: v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
    readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly htmlPath: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly sectionDepth: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>;
    readonly transformDocumentList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
        children: any;
    }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
        children: any;
    }[]) => any, {
        readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
        readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
    }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
        children: any;
    }[]) => any, string>]>;
    readonly transformSectionList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
        children: any;
    }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
        children: any;
    }[]) => any, {
        readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
        readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
    }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
        children: any;
    }[]) => any, string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>, undefined>;
        readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
        }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, string>]>, undefined>;
        readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
        }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    }, {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
    readonly '~types'?: {
        readonly input: {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        };
        readonly output: {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        };
        readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
    } | undefined;
}, v.TitleAction<{
    title?: string | undefined;
    htmlPath?: string | undefined;
    sectionDepth?: number | undefined;
    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
        children: any;
    }[]) => any) | undefined;
    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
        children: any;
    }[]) => any) | undefined;
}, "TocConfig">]>;
type TocConfig = v.InferInput<typeof TocConfig>;
declare const CoverConfig: v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly src: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly src: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: src">;
    };
    readonly '~standard': v.StandardProps<{
        src: string;
    }, {
        src: string;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        src: string;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
    readonly '~types'?: {
        readonly input: {
            src: string;
        };
        readonly output: {
            src: string;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly name: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>;
    readonly htmlPath: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly name: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>, undefined>;
        readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }, {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
    readonly '~types'?: {
        readonly input: {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        };
        readonly output: {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
    } | undefined;
}], undefined>, v.TitleAction<{
    src: string;
} & {
    name?: string | undefined;
    htmlPath?: string | boolean | undefined;
}, "CoverConfig">]>;
type CoverConfig = v.InferInput<typeof CoverConfig>;
declare const VfmConfig: v.SchemaWithPipe<readonly [Omit<v.LooseObjectSchema<{
    readonly style: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    readonly partial: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly language: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly replace: v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
        readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
        readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
            readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
        }>]>;
    }, undefined>, undefined>, v.DescriptionAction<({
        test: RegExp;
        match: (result: RegExpMatchArray, h: any) => Object | string;
    } & {
        [key: string]: unknown;
    })[], string>]>;
    readonly hardLineBreaks: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly disableFormatHtml: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly math: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly style: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        readonly partial: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly language: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly replace: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
            readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
            readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
            }>]>;
        }, undefined>, undefined>, v.DescriptionAction<({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[], string>]>, undefined>;
        readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly math: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        style?: string | string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }, {
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }, v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue>;
    readonly '~types'?: {
        readonly input: {
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        };
        readonly output: {
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        };
        readonly issue: v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue;
    } | undefined;
}, v.TitleAction<{
    style?: string[] | undefined;
    partial?: boolean | undefined;
    title?: string | undefined;
    language?: string | undefined;
    replace?: ({
        test: RegExp;
        match: (result: RegExpMatchArray, h: any) => Object | string;
    } & {
        [key: string]: unknown;
    })[] | undefined;
    hardLineBreaks?: boolean | undefined;
    disableFormatHtml?: boolean | undefined;
    math?: boolean | undefined;
} & {
    [key: string]: unknown;
}, "VfmConfig">]>;
type VfmConfig = v.InferInput<typeof VfmConfig>;
declare const ServerConfig: v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
    readonly host: v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>;
    readonly port: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>;
    readonly proxy: v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
        readonly typeString: "import(\"vite\").ProxyOptions";
    }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
        [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
    }, string>]>;
    readonly allowedHosts: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly host: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
        readonly port: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>, undefined>;
        readonly proxy: v.OptionalSchema<v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
            readonly typeString: "import(\"vite\").ProxyOptions";
        }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        }, string>]>, undefined>;
        readonly allowedHosts: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    }, {
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>;
    readonly '~types'?: {
        readonly input: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        };
        readonly output: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>;
    } | undefined;
}, v.TitleAction<{
    host?: string | boolean | undefined;
    port?: number | undefined;
    proxy?: {
        [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
    } | undefined;
    allowedHosts?: boolean | string[] | undefined;
}, "ServerConfig">]>;
type ServerConfig = v.InferInput<typeof ServerConfig>;
declare const BuildTask: v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly entry: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.ObjectSchema<{
        readonly rel: v.LiteralSchema<"contents", undefined>;
        readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
        readonly pageCounterReset: v.SchemaWithPipe<readonly [v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, undefined>, v.DescriptionAction<number | undefined, string>]>;
    }, undefined>, v.TitleAction<{
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    }, "ContentsEntryConfig">]>, v.SchemaWithPipe<readonly [v.ObjectSchema<{
        readonly rel: v.LiteralSchema<"cover", undefined>;
        readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
    }, undefined>, v.TitleAction<{
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    }, "CoverEntryConfig">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
        readonly '~types'?: {
            readonly input: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly output: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
        } | undefined;
    }, v.TitleAction<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    }, "ArticleEntryConfig">]>], undefined>], undefined>, undefined>, v.MinLengthAction<(string | {
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], 1, "At least one entry is required">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
        readonly '~types'?: {
            readonly input: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly output: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
        } | undefined;
    }, v.TitleAction<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    }, "ArticleEntryConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    } | (string | {
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], ({
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[]>, v.DescriptionAction<({
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly entry: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.ObjectSchema<{
            readonly rel: v.LiteralSchema<"contents", undefined>;
            readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
            readonly pageCounterReset: v.SchemaWithPipe<readonly [v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, undefined>, v.DescriptionAction<number | undefined, string>]>;
        }, undefined>, v.TitleAction<{
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        }, "ContentsEntryConfig">]>, v.SchemaWithPipe<readonly [v.ObjectSchema<{
            readonly rel: v.LiteralSchema<"cover", undefined>;
            readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
            readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
        }, undefined>, v.TitleAction<{
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        }, "CoverEntryConfig">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
                readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                    };
                    readonly '~standard': v.StandardProps<{
                        specifier: string;
                    }, {
                        specifier: string;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly '~types'?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                    };
                    readonly '~standard': v.StandardProps<{
                        import?: string | string[] | undefined;
                    }, {
                        import?: string[] | undefined;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        import?: string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                    readonly '~types'?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                    };
                    readonly '~standard': v.StandardProps<{
                        specifier: string;
                    }, {
                        specifier: string;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly '~types'?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                    };
                    readonly '~standard': v.StandardProps<{
                        import?: string | string[] | undefined;
                    }, {
                        import?: string[] | undefined;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        import?: string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                    readonly '~types'?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }))[], ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[]>]>, undefined>;
                readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            }, {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly output: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: ({
                        specifier: string;
                    } & {
                        import?: string[] | undefined;
                    })[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
            } | undefined;
        }, v.TitleAction<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }, "ArticleEntryConfig">]>], undefined>], undefined>, undefined>, v.MinLengthAction<(string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], 1, "At least one entry is required">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
                readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                    };
                    readonly '~standard': v.StandardProps<{
                        specifier: string;
                    }, {
                        specifier: string;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly '~types'?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                    };
                    readonly '~standard': v.StandardProps<{
                        import?: string | string[] | undefined;
                    }, {
                        import?: string[] | undefined;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        import?: string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                    readonly '~types'?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                    };
                    readonly '~standard': v.StandardProps<{
                        specifier: string;
                    }, {
                        specifier: string;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly '~types'?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                    };
                    readonly '~standard': v.StandardProps<{
                        import?: string | string[] | undefined;
                    }, {
                        import?: string[] | undefined;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        import?: string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                    readonly '~types'?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }))[], ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[]>]>, undefined>;
                readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            }, {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly output: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: ({
                        specifier: string;
                    } & {
                        import?: string[] | undefined;
                    })[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
            } | undefined;
        }, v.TitleAction<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }, "ArticleEntryConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], ({
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[]>, v.DescriptionAction<({
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], string>]>, "Missing required field: entry">;
    };
    readonly '~standard': v.StandardProps<{
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    }, {
        entry: ({
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[];
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        entry: ({
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[];
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], 1> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], 1>>>;
    readonly '~types'?: {
        readonly input: {
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        };
        readonly output: {
            entry: ({
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            })[];
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], 1> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], 1>>;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly author: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly theme: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }))[], ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[]>]>, v.DescriptionAction<({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[], string>]>;
    readonly entryContext: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly output: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
        }, {
            path: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
        readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
        readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
        readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly '~types'?: {
            readonly input: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
        }, {
            path: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
        readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
        readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
        readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly '~types'?: {
            readonly input: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[], ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[]>, v.DescriptionAction<({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[], string>]>;
    readonly workspaceDir: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    /** @deprecated */
    readonly includeAssets: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.MetadataAction<string[], {
        readonly deprecated: true;
    }>, v.DescriptionAction<string[], string>]>;
    readonly copyAsset: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly includes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
        readonly excludes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
        readonly includeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
        readonly excludeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly includes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
            readonly excludes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
            readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
            readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>>;
        readonly '~types'?: {
            readonly input: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            };
            readonly output: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>;
        } | undefined;
    }, v.TitleAction<{
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    }, "CopyAssetConfig">]>], undefined>, v.DescriptionAction<{
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    }, string>]>;
    readonly size: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly pressReady: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly language: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly readingProgression: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", string>]>;
    readonly toc: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        readonly htmlPath: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        readonly sectionDepth: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>;
        readonly transformDocumentList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
        }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, string>]>;
        readonly transformSectionList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
        }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
            readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
            readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>, undefined>;
            readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
            }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, string>]>, undefined>;
            readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
            }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
        readonly '~types'?: {
            readonly input: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            };
            readonly output: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            };
            readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
        } | undefined;
    }, v.TitleAction<{
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    }, "TocConfig">]>, v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | boolean | {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    }, {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined>, v.DescriptionAction<{
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined, string>]>;
    /** @deprecated */
    readonly tocTitle: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.MetadataAction<string, {
        readonly deprecated: true;
    }>, v.DescriptionAction<string, string>]>;
    readonly cover: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly src: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly src: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: src">;
        };
        readonly '~standard': v.StandardProps<{
            src: string;
        }, {
            src: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            src: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                src: string;
            };
            readonly output: {
                src: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly name: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>;
        readonly htmlPath: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly name: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>, undefined>;
            readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }, {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
        readonly '~types'?: {
            readonly input: {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            };
            readonly output: {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }, "CoverConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }), {
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }>, v.DescriptionAction<{
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }, string>]>;
    readonly timeout: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.DescriptionAction<number, string>]>;
    readonly documentProcessor: v.SchemaWithPipe<readonly [v.GenericSchema<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor>, v.MetadataAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, {
        readonly typeString: "(option: import(\"@vivliostyle/vfm\").StringifyMarkdownOptions, metadata: import(\"@vivliostyle/vfm\").Metadata) => import(\"unified\").Processor";
    }>, v.DescriptionAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, string>]>;
    readonly vfm: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.LooseObjectSchema<{
        readonly style: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        readonly partial: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
        readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        readonly language: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        readonly replace: v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
            readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
            readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
            }>]>;
        }, undefined>, undefined>, v.DescriptionAction<({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[], string>]>;
        readonly hardLineBreaks: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
        readonly disableFormatHtml: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
        readonly math: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly style: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            readonly partial: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
            readonly language: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
            readonly replace: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
                readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                    readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                }>]>;
            }, undefined>, undefined>, v.DescriptionAction<({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[], string>]>, undefined>;
            readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
            readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
            readonly math: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, {
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue>;
        readonly '~types'?: {
            readonly input: {
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            };
            readonly output: {
                style?: string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            };
            readonly issue: v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue;
        } | undefined;
    }, v.TitleAction<{
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }, "VfmConfig">]>], undefined>, v.DescriptionAction<{
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }, string>]>;
    readonly image: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.CheckAction<string, `The specified image is not compatible with the CLI version ${any}. Please check the image version.`>, v.DescriptionAction<string, string>]>;
    /** @deprecated */
    readonly http: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.MetadataAction<boolean, {
        readonly deprecated: true;
    }>, v.DescriptionAction<boolean, string>]>;
    readonly viewer: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly viewerParam: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly browser: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", string>]>;
    readonly base: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.RegexAction<string, "Base path must start with a slash">, v.CheckAction<string, "Base path must not be root">, v.TransformAction<string, string>, v.DescriptionAction<string, string>]>;
    readonly server: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly host: v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>;
        readonly port: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>;
        readonly proxy: v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
            readonly typeString: "import(\"vite\").ProxyOptions";
        }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        }, string>]>;
        readonly allowedHosts: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly host: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
            readonly port: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>, undefined>;
            readonly proxy: v.OptionalSchema<v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
                readonly typeString: "import(\"vite\").ProxyOptions";
            }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            }, string>]>, undefined>;
            readonly allowedHosts: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }, {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>;
        readonly '~types'?: {
            readonly input: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            };
            readonly output: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>;
        } | undefined;
    }, v.TitleAction<{
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    }, "ServerConfig">]>], undefined>, v.DescriptionAction<{
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    }, string>]>;
    readonly static: v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.RegexAction<string, "Base path must start with a slash">, v.TransformAction<string, string>]>, v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>, v.DescriptionAction<{
        [x: string]: string[];
    }, string>, v.TransformAction<{
        [x: string]: string[];
    }, {
        [x: string]: string[];
    }>]>;
    readonly temporaryFilePrefix: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly vite: v.SchemaWithPipe<readonly [v.CustomSchema<vite.UserConfig, undefined>, v.MetadataAction<vite.UserConfig, {
        readonly typeString: "import(\"vite\").UserConfig";
    }>, v.DescriptionAction<vite.UserConfig, string>]>;
    readonly viteConfigFile: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly author: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, v.DescriptionAction<({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[], string>]>, undefined>;
        readonly entryContext: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
            }, {
                path: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
            readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
            readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
            readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly '~types'?: {
                readonly input: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
            }, {
                path: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
            readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
            readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
            readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly '~types'?: {
                readonly input: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[], ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[]>, v.DescriptionAction<({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[], string>]>, undefined>;
        readonly workspaceDir: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly includeAssets: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.MetadataAction<string[], {
            readonly deprecated: true;
        }>, v.DescriptionAction<string[], string>]>, undefined>;
        readonly copyAsset: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly includes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
            readonly excludes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
            readonly includeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
            readonly excludeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly includes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
                readonly excludes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
                readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
                readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            }, {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>>;
            readonly '~types'?: {
                readonly input: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                };
                readonly output: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>;
            } | undefined;
        }, v.TitleAction<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, "CopyAssetConfig">]>], undefined>, v.DescriptionAction<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, string>]>, undefined>;
        readonly size: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly pressReady: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly language: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly readingProgression: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", string>]>, undefined>;
        readonly toc: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            readonly htmlPath: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            readonly sectionDepth: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>;
            readonly transformDocumentList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
            }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, string>]>;
            readonly transformSectionList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
            }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
                readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
                readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>, undefined>;
                readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, {
                    readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                    readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
                }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, string>]>, undefined>;
                readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, {
                    readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                    readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
                }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            }, {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
            readonly '~types'?: {
                readonly input: {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                };
                readonly output: {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                };
                readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
            } | undefined;
        }, v.TitleAction<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, "TocConfig">]>, v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined>, v.DescriptionAction<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined, string>]>, undefined>;
        readonly tocTitle: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.MetadataAction<string, {
            readonly deprecated: true;
        }>, v.DescriptionAction<string, string>]>, undefined>;
        readonly cover: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly src: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly src: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: src">;
            };
            readonly '~standard': v.StandardProps<{
                src: string;
            }, {
                src: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                src: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    src: string;
                };
                readonly output: {
                    src: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly name: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>;
            readonly htmlPath: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly name: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>, undefined>;
                readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }, {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
            readonly '~types'?: {
                readonly input: {
                    name?: string | undefined;
                    htmlPath?: string | boolean | undefined;
                };
                readonly output: {
                    name?: string | undefined;
                    htmlPath?: string | boolean | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }, "CoverConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }), {
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }>, v.DescriptionAction<{
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }, string>]>, undefined>;
        readonly timeout: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.DescriptionAction<number, string>]>, undefined>;
        readonly documentProcessor: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor>, v.MetadataAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, {
            readonly typeString: "(option: import(\"@vivliostyle/vfm\").StringifyMarkdownOptions, metadata: import(\"@vivliostyle/vfm\").Metadata) => import(\"unified\").Processor";
        }>, v.DescriptionAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, string>]>, undefined>;
        readonly vfm: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.LooseObjectSchema<{
            readonly style: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            readonly partial: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
            readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            readonly language: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            readonly replace: v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
                readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                    readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                }>]>;
            }, undefined>, undefined>, v.DescriptionAction<({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[], string>]>;
            readonly hardLineBreaks: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
            readonly disableFormatHtml: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
            readonly math: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly style: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                readonly partial: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
                readonly language: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
                readonly replace: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
                    readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                    readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                        readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                    }>]>;
                }, undefined>, undefined>, v.DescriptionAction<({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[], string>]>, undefined>;
                readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
                readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
                readonly math: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }, {
                style?: string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                style?: string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }, v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue>;
            readonly '~types'?: {
                readonly input: {
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    title?: string | undefined;
                    language?: string | undefined;
                    replace?: ({
                        test: RegExp;
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                };
                readonly output: {
                    style?: string[] | undefined;
                    partial?: boolean | undefined;
                    title?: string | undefined;
                    language?: string | undefined;
                    replace?: ({
                        test: RegExp;
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                };
                readonly issue: v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue;
            } | undefined;
        }, v.TitleAction<{
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, "VfmConfig">]>], undefined>, v.DescriptionAction<{
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, string>]>, undefined>;
        readonly image: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.CheckAction<string, `The specified image is not compatible with the CLI version ${any}. Please check the image version.`>, v.DescriptionAction<string, string>]>, undefined>;
        readonly http: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.MetadataAction<boolean, {
            readonly deprecated: true;
        }>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly viewer: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly viewerParam: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly browser: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", string>]>, undefined>;
        readonly base: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.RegexAction<string, "Base path must start with a slash">, v.CheckAction<string, "Base path must not be root">, v.TransformAction<string, string>, v.DescriptionAction<string, string>]>, undefined>;
        readonly server: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly host: v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>;
            readonly port: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>;
            readonly proxy: v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
                readonly typeString: "import(\"vite\").ProxyOptions";
            }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            }, string>]>;
            readonly allowedHosts: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly host: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
                readonly port: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>, undefined>;
                readonly proxy: v.OptionalSchema<v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
                    readonly typeString: "import(\"vite\").ProxyOptions";
                }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                }, string>]>, undefined>;
                readonly allowedHosts: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            }, {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>;
            readonly '~types'?: {
                readonly input: {
                    host?: string | boolean | undefined;
                    port?: number | undefined;
                    proxy?: {
                        [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                    } | undefined;
                    allowedHosts?: boolean | string[] | undefined;
                };
                readonly output: {
                    host?: string | boolean | undefined;
                    port?: number | undefined;
                    proxy?: {
                        [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                    } | undefined;
                    allowedHosts?: boolean | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>;
            } | undefined;
        }, v.TitleAction<{
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }, "ServerConfig">]>], undefined>, v.DescriptionAction<{
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }, string>]>, undefined>;
        readonly static: v.OptionalSchema<v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.RegexAction<string, "Base path must start with a slash">, v.TransformAction<string, string>]>, v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>, v.DescriptionAction<{
            [x: string]: string[];
        }, string>, v.TransformAction<{
            [x: string]: string[];
        }, {
            [x: string]: string[];
        }>]>, undefined>;
        readonly temporaryFilePrefix: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly vite: v.OptionalSchema<v.SchemaWithPipe<readonly [v.CustomSchema<vite.UserConfig, undefined>, v.MetadataAction<vite.UserConfig, {
            readonly typeString: "import(\"vite\").UserConfig";
        }>, v.DescriptionAction<vite.UserConfig, string>]>, undefined>;
        readonly viteConfigFile: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }, {
        title?: string | undefined;
        author?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        entryContext?: string | undefined;
        output?: ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: string[];
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        title?: string | undefined;
        author?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        entryContext?: string | undefined;
        output?: ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: string[];
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }, v.BaseIssue<unknown> | v.ObjectIssue | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.CheckIssue<string[]> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6> | v.UnionIssue<v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>> | v.InstanceIssue | v.UnionIssue<v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue> | v.CheckIssue<string> | v.RegexIssue<string> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>>;
    readonly '~types'?: {
        readonly input: {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        };
        readonly output: {
            title?: string | undefined;
            author?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            entryContext?: string | undefined;
            output?: ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            } & {
                format: OutputFormat;
            })[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: string[];
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        };
        readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.CheckIssue<string[]> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6> | v.UnionIssue<v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>> | v.InstanceIssue | v.UnionIssue<v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue> | v.CheckIssue<string> | v.RegexIssue<string> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>;
    } | undefined;
}], undefined>, v.TitleAction<{
    entry: ({
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[];
} & {
    title?: string | undefined;
    author?: string | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    entryContext?: string | undefined;
    output?: ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[] | undefined;
    workspaceDir?: string | undefined;
    includeAssets?: string[] | undefined;
    copyAsset?: {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    } | undefined;
    size?: string | undefined;
    pressReady?: boolean | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    toc?: {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined;
    tocTitle?: string | undefined;
    cover?: ({
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }) | undefined;
    timeout?: number | undefined;
    documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
    vfm?: ({
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }) | undefined;
    image?: string | undefined;
    http?: boolean | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
    base?: string | undefined;
    server?: {
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    } | undefined;
    static?: {
        [x: string]: string[];
    } | undefined;
    temporaryFilePrefix?: string | undefined;
    vite?: vite.UserConfig | undefined;
    viteConfigFile?: string | boolean | undefined;
}, "BuildTask">]>;
type BuildTask = v.InferInput<typeof BuildTask>;
type ParsedBuildTask = v.InferOutput<typeof BuildTask>;
/** @hidden */
declare const VivliostyleConfigSchema: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly entry: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.ObjectSchema<{
        readonly rel: v.LiteralSchema<"contents", undefined>;
        readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
        readonly pageCounterReset: v.SchemaWithPipe<readonly [v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, undefined>, v.DescriptionAction<number | undefined, string>]>;
    }, undefined>, v.TitleAction<{
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    }, "ContentsEntryConfig">]>, v.SchemaWithPipe<readonly [v.ObjectSchema<{
        readonly rel: v.LiteralSchema<"cover", undefined>;
        readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
    }, undefined>, v.TitleAction<{
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    }, "CoverEntryConfig">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
        readonly '~types'?: {
            readonly input: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly output: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
        } | undefined;
    }, v.TitleAction<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    }, "ArticleEntryConfig">]>], undefined>], undefined>, undefined>, v.MinLengthAction<(string | {
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], 1, "At least one entry is required">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
        readonly '~types'?: {
            readonly input: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly output: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
        } | undefined;
    }, v.TitleAction<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    }, "ArticleEntryConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    } | (string | {
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], ({
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[]>, v.DescriptionAction<({
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly entry: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.ObjectSchema<{
            readonly rel: v.LiteralSchema<"contents", undefined>;
            readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
            readonly pageCounterReset: v.SchemaWithPipe<readonly [v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, undefined>, v.DescriptionAction<number | undefined, string>]>;
        }, undefined>, v.TitleAction<{
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        }, "ContentsEntryConfig">]>, v.SchemaWithPipe<readonly [v.ObjectSchema<{
            readonly rel: v.LiteralSchema<"cover", undefined>;
            readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
            readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
        }, undefined>, v.TitleAction<{
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        }, "CoverEntryConfig">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
                readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                    };
                    readonly '~standard': v.StandardProps<{
                        specifier: string;
                    }, {
                        specifier: string;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly '~types'?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                    };
                    readonly '~standard': v.StandardProps<{
                        import?: string | string[] | undefined;
                    }, {
                        import?: string[] | undefined;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        import?: string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                    readonly '~types'?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                    };
                    readonly '~standard': v.StandardProps<{
                        specifier: string;
                    }, {
                        specifier: string;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly '~types'?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                    };
                    readonly '~standard': v.StandardProps<{
                        import?: string | string[] | undefined;
                    }, {
                        import?: string[] | undefined;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        import?: string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                    readonly '~types'?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }))[], ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[]>]>, undefined>;
                readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            }, {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly output: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: ({
                        specifier: string;
                    } & {
                        import?: string[] | undefined;
                    })[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
            } | undefined;
        }, v.TitleAction<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }, "ArticleEntryConfig">]>], undefined>], undefined>, undefined>, v.MinLengthAction<(string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], 1, "At least one entry is required">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
                readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                    };
                    readonly '~standard': v.StandardProps<{
                        specifier: string;
                    }, {
                        specifier: string;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly '~types'?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                    };
                    readonly '~standard': v.StandardProps<{
                        import?: string | string[] | undefined;
                    }, {
                        import?: string[] | undefined;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        import?: string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                    readonly '~types'?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                    };
                    readonly '~standard': v.StandardProps<{
                        specifier: string;
                    }, {
                        specifier: string;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly '~types'?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                    };
                    readonly '~standard': v.StandardProps<{
                        import?: string | string[] | undefined;
                    }, {
                        import?: string[] | undefined;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        import?: string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                    readonly '~types'?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }))[], ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[]>]>, undefined>;
                readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            }, {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly output: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: ({
                        specifier: string;
                    } & {
                        import?: string[] | undefined;
                    })[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
            } | undefined;
        }, v.TitleAction<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }, "ArticleEntryConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], ({
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[]>, v.DescriptionAction<({
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], string>]>, "Missing required field: entry">;
    };
    readonly '~standard': v.StandardProps<{
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    }, {
        entry: ({
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[];
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        entry: ({
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[];
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], 1> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], 1>>>;
    readonly '~types'?: {
        readonly input: {
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        };
        readonly output: {
            entry: ({
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            })[];
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], 1> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], 1>>;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly author: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly theme: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }))[], ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[]>]>, v.DescriptionAction<({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[], string>]>;
    readonly entryContext: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly output: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
        }, {
            path: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
        readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
        readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
        readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly '~types'?: {
            readonly input: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
        }, {
            path: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
        readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
        readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
        readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly '~types'?: {
            readonly input: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[], ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[]>, v.DescriptionAction<({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[], string>]>;
    readonly workspaceDir: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    /** @deprecated */
    readonly includeAssets: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.MetadataAction<string[], {
        readonly deprecated: true;
    }>, v.DescriptionAction<string[], string>]>;
    readonly copyAsset: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly includes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
        readonly excludes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
        readonly includeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
        readonly excludeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly includes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
            readonly excludes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
            readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
            readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>>;
        readonly '~types'?: {
            readonly input: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            };
            readonly output: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>;
        } | undefined;
    }, v.TitleAction<{
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    }, "CopyAssetConfig">]>], undefined>, v.DescriptionAction<{
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    }, string>]>;
    readonly size: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly pressReady: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly language: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly readingProgression: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", string>]>;
    readonly toc: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        readonly htmlPath: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        readonly sectionDepth: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>;
        readonly transformDocumentList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
        }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, string>]>;
        readonly transformSectionList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
        }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
            readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
            readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>, undefined>;
            readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
            }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, string>]>, undefined>;
            readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
            }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
        readonly '~types'?: {
            readonly input: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            };
            readonly output: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            };
            readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
        } | undefined;
    }, v.TitleAction<{
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    }, "TocConfig">]>, v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | boolean | {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    }, {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined>, v.DescriptionAction<{
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined, string>]>;
    /** @deprecated */
    readonly tocTitle: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.MetadataAction<string, {
        readonly deprecated: true;
    }>, v.DescriptionAction<string, string>]>;
    readonly cover: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly src: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly src: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: src">;
        };
        readonly '~standard': v.StandardProps<{
            src: string;
        }, {
            src: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            src: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                src: string;
            };
            readonly output: {
                src: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly name: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>;
        readonly htmlPath: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly name: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>, undefined>;
            readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }, {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
        readonly '~types'?: {
            readonly input: {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            };
            readonly output: {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }, "CoverConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }), {
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }>, v.DescriptionAction<{
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }, string>]>;
    readonly timeout: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.DescriptionAction<number, string>]>;
    readonly documentProcessor: v.SchemaWithPipe<readonly [v.GenericSchema<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor>, v.MetadataAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, {
        readonly typeString: "(option: import(\"@vivliostyle/vfm\").StringifyMarkdownOptions, metadata: import(\"@vivliostyle/vfm\").Metadata) => import(\"unified\").Processor";
    }>, v.DescriptionAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, string>]>;
    readonly vfm: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.LooseObjectSchema<{
        readonly style: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        readonly partial: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
        readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        readonly language: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        readonly replace: v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
            readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
            readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
            }>]>;
        }, undefined>, undefined>, v.DescriptionAction<({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[], string>]>;
        readonly hardLineBreaks: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
        readonly disableFormatHtml: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
        readonly math: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly style: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            readonly partial: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
            readonly language: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
            readonly replace: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
                readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                    readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                }>]>;
            }, undefined>, undefined>, v.DescriptionAction<({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[], string>]>, undefined>;
            readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
            readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
            readonly math: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, {
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue>;
        readonly '~types'?: {
            readonly input: {
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            };
            readonly output: {
                style?: string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            };
            readonly issue: v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue;
        } | undefined;
    }, v.TitleAction<{
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }, "VfmConfig">]>], undefined>, v.DescriptionAction<{
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }, string>]>;
    readonly image: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.CheckAction<string, `The specified image is not compatible with the CLI version ${any}. Please check the image version.`>, v.DescriptionAction<string, string>]>;
    /** @deprecated */
    readonly http: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.MetadataAction<boolean, {
        readonly deprecated: true;
    }>, v.DescriptionAction<boolean, string>]>;
    readonly viewer: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly viewerParam: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly browser: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", string>]>;
    readonly base: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.RegexAction<string, "Base path must start with a slash">, v.CheckAction<string, "Base path must not be root">, v.TransformAction<string, string>, v.DescriptionAction<string, string>]>;
    readonly server: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly host: v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>;
        readonly port: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>;
        readonly proxy: v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
            readonly typeString: "import(\"vite\").ProxyOptions";
        }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        }, string>]>;
        readonly allowedHosts: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly host: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
            readonly port: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>, undefined>;
            readonly proxy: v.OptionalSchema<v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
                readonly typeString: "import(\"vite\").ProxyOptions";
            }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            }, string>]>, undefined>;
            readonly allowedHosts: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }, {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>;
        readonly '~types'?: {
            readonly input: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            };
            readonly output: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>;
        } | undefined;
    }, v.TitleAction<{
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    }, "ServerConfig">]>], undefined>, v.DescriptionAction<{
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    }, string>]>;
    readonly static: v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.RegexAction<string, "Base path must start with a slash">, v.TransformAction<string, string>]>, v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>, v.DescriptionAction<{
        [x: string]: string[];
    }, string>, v.TransformAction<{
        [x: string]: string[];
    }, {
        [x: string]: string[];
    }>]>;
    readonly temporaryFilePrefix: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly vite: v.SchemaWithPipe<readonly [v.CustomSchema<vite.UserConfig, undefined>, v.MetadataAction<vite.UserConfig, {
        readonly typeString: "import(\"vite\").UserConfig";
    }>, v.DescriptionAction<vite.UserConfig, string>]>;
    readonly viteConfigFile: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly author: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, v.DescriptionAction<({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[], string>]>, undefined>;
        readonly entryContext: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
            }, {
                path: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
            readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
            readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
            readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly '~types'?: {
                readonly input: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
            }, {
                path: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
            readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
            readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
            readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly '~types'?: {
                readonly input: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[], ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[]>, v.DescriptionAction<({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[], string>]>, undefined>;
        readonly workspaceDir: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly includeAssets: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.MetadataAction<string[], {
            readonly deprecated: true;
        }>, v.DescriptionAction<string[], string>]>, undefined>;
        readonly copyAsset: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly includes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
            readonly excludes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
            readonly includeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
            readonly excludeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly includes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
                readonly excludes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
                readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
                readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            }, {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>>;
            readonly '~types'?: {
                readonly input: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                };
                readonly output: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>;
            } | undefined;
        }, v.TitleAction<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, "CopyAssetConfig">]>], undefined>, v.DescriptionAction<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, string>]>, undefined>;
        readonly size: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly pressReady: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly language: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly readingProgression: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", string>]>, undefined>;
        readonly toc: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            readonly htmlPath: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            readonly sectionDepth: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>;
            readonly transformDocumentList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
            }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, string>]>;
            readonly transformSectionList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
            }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
                readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
                readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>, undefined>;
                readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, {
                    readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                    readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
                }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, string>]>, undefined>;
                readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, {
                    readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                    readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
                }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            }, {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
            readonly '~types'?: {
                readonly input: {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                };
                readonly output: {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                };
                readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
            } | undefined;
        }, v.TitleAction<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, "TocConfig">]>, v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined>, v.DescriptionAction<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined, string>]>, undefined>;
        readonly tocTitle: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.MetadataAction<string, {
            readonly deprecated: true;
        }>, v.DescriptionAction<string, string>]>, undefined>;
        readonly cover: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly src: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly src: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: src">;
            };
            readonly '~standard': v.StandardProps<{
                src: string;
            }, {
                src: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                src: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    src: string;
                };
                readonly output: {
                    src: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly name: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>;
            readonly htmlPath: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly name: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>, undefined>;
                readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }, {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
            readonly '~types'?: {
                readonly input: {
                    name?: string | undefined;
                    htmlPath?: string | boolean | undefined;
                };
                readonly output: {
                    name?: string | undefined;
                    htmlPath?: string | boolean | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }, "CoverConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }), {
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }>, v.DescriptionAction<{
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }, string>]>, undefined>;
        readonly timeout: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.DescriptionAction<number, string>]>, undefined>;
        readonly documentProcessor: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor>, v.MetadataAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, {
            readonly typeString: "(option: import(\"@vivliostyle/vfm\").StringifyMarkdownOptions, metadata: import(\"@vivliostyle/vfm\").Metadata) => import(\"unified\").Processor";
        }>, v.DescriptionAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, string>]>, undefined>;
        readonly vfm: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.LooseObjectSchema<{
            readonly style: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            readonly partial: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
            readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            readonly language: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            readonly replace: v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
                readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                    readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                }>]>;
            }, undefined>, undefined>, v.DescriptionAction<({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[], string>]>;
            readonly hardLineBreaks: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
            readonly disableFormatHtml: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
            readonly math: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly style: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                readonly partial: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
                readonly language: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
                readonly replace: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
                    readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                    readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                        readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                    }>]>;
                }, undefined>, undefined>, v.DescriptionAction<({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[], string>]>, undefined>;
                readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
                readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
                readonly math: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }, {
                style?: string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                style?: string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }, v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue>;
            readonly '~types'?: {
                readonly input: {
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    title?: string | undefined;
                    language?: string | undefined;
                    replace?: ({
                        test: RegExp;
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                };
                readonly output: {
                    style?: string[] | undefined;
                    partial?: boolean | undefined;
                    title?: string | undefined;
                    language?: string | undefined;
                    replace?: ({
                        test: RegExp;
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                };
                readonly issue: v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue;
            } | undefined;
        }, v.TitleAction<{
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, "VfmConfig">]>], undefined>, v.DescriptionAction<{
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, string>]>, undefined>;
        readonly image: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.CheckAction<string, `The specified image is not compatible with the CLI version ${any}. Please check the image version.`>, v.DescriptionAction<string, string>]>, undefined>;
        readonly http: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.MetadataAction<boolean, {
            readonly deprecated: true;
        }>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly viewer: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly viewerParam: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly browser: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", string>]>, undefined>;
        readonly base: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.RegexAction<string, "Base path must start with a slash">, v.CheckAction<string, "Base path must not be root">, v.TransformAction<string, string>, v.DescriptionAction<string, string>]>, undefined>;
        readonly server: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly host: v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>;
            readonly port: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>;
            readonly proxy: v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
                readonly typeString: "import(\"vite\").ProxyOptions";
            }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            }, string>]>;
            readonly allowedHosts: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly host: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
                readonly port: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>, undefined>;
                readonly proxy: v.OptionalSchema<v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
                    readonly typeString: "import(\"vite\").ProxyOptions";
                }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                }, string>]>, undefined>;
                readonly allowedHosts: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            }, {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>;
            readonly '~types'?: {
                readonly input: {
                    host?: string | boolean | undefined;
                    port?: number | undefined;
                    proxy?: {
                        [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                    } | undefined;
                    allowedHosts?: boolean | string[] | undefined;
                };
                readonly output: {
                    host?: string | boolean | undefined;
                    port?: number | undefined;
                    proxy?: {
                        [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                    } | undefined;
                    allowedHosts?: boolean | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>;
            } | undefined;
        }, v.TitleAction<{
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }, "ServerConfig">]>], undefined>, v.DescriptionAction<{
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }, string>]>, undefined>;
        readonly static: v.OptionalSchema<v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.RegexAction<string, "Base path must start with a slash">, v.TransformAction<string, string>]>, v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>, v.DescriptionAction<{
            [x: string]: string[];
        }, string>, v.TransformAction<{
            [x: string]: string[];
        }, {
            [x: string]: string[];
        }>]>, undefined>;
        readonly temporaryFilePrefix: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly vite: v.OptionalSchema<v.SchemaWithPipe<readonly [v.CustomSchema<vite.UserConfig, undefined>, v.MetadataAction<vite.UserConfig, {
            readonly typeString: "import(\"vite\").UserConfig";
        }>, v.DescriptionAction<vite.UserConfig, string>]>, undefined>;
        readonly viteConfigFile: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }, {
        title?: string | undefined;
        author?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        entryContext?: string | undefined;
        output?: ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: string[];
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        title?: string | undefined;
        author?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        entryContext?: string | undefined;
        output?: ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: string[];
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }, v.BaseIssue<unknown> | v.ObjectIssue | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.CheckIssue<string[]> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6> | v.UnionIssue<v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>> | v.InstanceIssue | v.UnionIssue<v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue> | v.CheckIssue<string> | v.RegexIssue<string> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>>;
    readonly '~types'?: {
        readonly input: {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        };
        readonly output: {
            title?: string | undefined;
            author?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            entryContext?: string | undefined;
            output?: ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            } & {
                format: OutputFormat;
            })[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: string[];
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        };
        readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.CheckIssue<string[]> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6> | v.UnionIssue<v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>> | v.InstanceIssue | v.UnionIssue<v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue> | v.CheckIssue<string> | v.RegexIssue<string> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>;
    } | undefined;
}], undefined>, v.TitleAction<{
    entry: ({
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[];
} & {
    title?: string | undefined;
    author?: string | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    entryContext?: string | undefined;
    output?: ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[] | undefined;
    workspaceDir?: string | undefined;
    includeAssets?: string[] | undefined;
    copyAsset?: {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    } | undefined;
    size?: string | undefined;
    pressReady?: boolean | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    toc?: {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined;
    tocTitle?: string | undefined;
    cover?: ({
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }) | undefined;
    timeout?: number | undefined;
    documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
    vfm?: ({
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }) | undefined;
    image?: string | undefined;
    http?: boolean | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
    base?: string | undefined;
    server?: {
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    } | undefined;
    static?: {
        [x: string]: string[];
    } | undefined;
    temporaryFilePrefix?: string | undefined;
    vite?: vite.UserConfig | undefined;
    viteConfigFile?: string | boolean | undefined;
}, "BuildTask">]>, undefined>, v.MinLengthAction<({
    entry: ({
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[];
} & {
    title?: string | undefined;
    author?: string | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    entryContext?: string | undefined;
    output?: ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[] | undefined;
    workspaceDir?: string | undefined;
    includeAssets?: string[] | undefined;
    copyAsset?: {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    } | undefined;
    size?: string | undefined;
    pressReady?: boolean | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    toc?: {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined;
    tocTitle?: string | undefined;
    cover?: ({
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }) | undefined;
    timeout?: number | undefined;
    documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
    vfm?: ({
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }) | undefined;
    image?: string | undefined;
    http?: boolean | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
    base?: string | undefined;
    server?: {
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    } | undefined;
    static?: {
        [x: string]: string[];
    } | undefined;
    temporaryFilePrefix?: string | undefined;
    vite?: vite.UserConfig | undefined;
    viteConfigFile?: string | boolean | undefined;
})[], 1, "At least one config entry is required">]>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly entry: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.ObjectSchema<{
        readonly rel: v.LiteralSchema<"contents", undefined>;
        readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
        readonly pageCounterReset: v.SchemaWithPipe<readonly [v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, undefined>, v.DescriptionAction<number | undefined, string>]>;
    }, undefined>, v.TitleAction<{
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    }, "ContentsEntryConfig">]>, v.SchemaWithPipe<readonly [v.ObjectSchema<{
        readonly rel: v.LiteralSchema<"cover", undefined>;
        readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
    }, undefined>, v.TitleAction<{
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    }, "CoverEntryConfig">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
        readonly '~types'?: {
            readonly input: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly output: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
        } | undefined;
    }, v.TitleAction<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    }, "ArticleEntryConfig">]>], undefined>], undefined>, undefined>, v.MinLengthAction<(string | {
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], 1, "At least one entry is required">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, undefined>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
        readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
        readonly '~types'?: {
            readonly input: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly output: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
        } | undefined;
    }, v.TitleAction<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    }, "ArticleEntryConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    } | (string | {
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], ({
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[]>, v.DescriptionAction<({
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly entry: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.ObjectSchema<{
            readonly rel: v.LiteralSchema<"contents", undefined>;
            readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
            readonly pageCounterReset: v.SchemaWithPipe<readonly [v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, undefined>, v.DescriptionAction<number | undefined, string>]>;
        }, undefined>, v.TitleAction<{
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        }, "ContentsEntryConfig">]>, v.SchemaWithPipe<readonly [v.ObjectSchema<{
            readonly rel: v.LiteralSchema<"cover", undefined>;
            readonly path: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
            readonly pageBreakBefore: v.SchemaWithPipe<readonly [v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, undefined>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, string>]>;
        }, undefined>, v.TitleAction<{
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        }, "CoverEntryConfig">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
                readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                    };
                    readonly '~standard': v.StandardProps<{
                        specifier: string;
                    }, {
                        specifier: string;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly '~types'?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                    };
                    readonly '~standard': v.StandardProps<{
                        import?: string | string[] | undefined;
                    }, {
                        import?: string[] | undefined;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        import?: string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                    readonly '~types'?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                    };
                    readonly '~standard': v.StandardProps<{
                        specifier: string;
                    }, {
                        specifier: string;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly '~types'?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                    };
                    readonly '~standard': v.StandardProps<{
                        import?: string | string[] | undefined;
                    }, {
                        import?: string[] | undefined;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        import?: string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                    readonly '~types'?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }))[], ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[]>]>, undefined>;
                readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            }, {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly output: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: ({
                        specifier: string;
                    } & {
                        import?: string[] | undefined;
                    })[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
            } | undefined;
        }, v.TitleAction<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }, "ArticleEntryConfig">]>], undefined>], undefined>, undefined>, v.MinLengthAction<(string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], 1, "At least one entry is required">]>, v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                };
                readonly '~standard': v.StandardProps<{
                    specifier: string;
                }, {
                    specifier: string;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly '~types'?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                };
                readonly '~standard': v.StandardProps<{
                    import?: string | string[] | undefined;
                }, {
                    import?: string[] | undefined;
                }>;
                readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                    import?: string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                readonly '~types'?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string[] | undefined;
            }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            }))[], ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[]>]>, undefined>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
            readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
                readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                    };
                    readonly '~standard': v.StandardProps<{
                        specifier: string;
                    }, {
                        specifier: string;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly '~types'?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                    };
                    readonly '~standard': v.StandardProps<{
                        import?: string | string[] | undefined;
                    }, {
                        import?: string[] | undefined;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        import?: string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                    readonly '~types'?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
                    };
                    readonly '~standard': v.StandardProps<{
                        specifier: string;
                    }, {
                        specifier: string;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly '~types'?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
                }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                    };
                    readonly '~standard': v.StandardProps<{
                        import?: string | string[] | undefined;
                    }, {
                        import?: string[] | undefined;
                    }>;
                    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                        import?: string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
                    readonly '~types'?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                }))[], ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[]>]>, undefined>;
                readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>;
                readonly rel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            }, {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly output: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: ({
                        specifier: string;
                    } & {
                        import?: string[] | undefined;
                    })[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>>;
            } | undefined;
        }, v.TitleAction<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        }, "ArticleEntryConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], ({
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[]>, v.DescriptionAction<({
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], string>]>, "Missing required field: entry">;
    };
    readonly '~standard': v.StandardProps<{
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    }, {
        entry: ({
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[];
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        entry: ({
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[];
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], 1> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[], 1>>>;
    readonly '~types'?: {
        readonly input: {
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        };
        readonly output: {
            entry: ({
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: ({
                    specifier: string;
                } & {
                    import?: string[] | undefined;
                })[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string[] | undefined;
            })[];
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], 1> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string[] | undefined;
        })[], 1>>;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly author: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly theme: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }))[], ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[]>]>, v.DescriptionAction<({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[], string>]>;
    readonly entryContext: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly output: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
        }, {
            path: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
        readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
        readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
        readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly '~types'?: {
            readonly input: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
        }, {
            path: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
        readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
        readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
        readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly '~types'?: {
            readonly input: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[], ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[]>, v.DescriptionAction<({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[], string>]>;
    readonly workspaceDir: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    /** @deprecated */
    readonly includeAssets: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.MetadataAction<string[], {
        readonly deprecated: true;
    }>, v.DescriptionAction<string[], string>]>;
    readonly copyAsset: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly includes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
        readonly excludes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
        readonly includeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
        readonly excludeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly includes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
            readonly excludes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
            readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
            readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>>;
        readonly '~types'?: {
            readonly input: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            };
            readonly output: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>;
        } | undefined;
    }, v.TitleAction<{
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    }, "CopyAssetConfig">]>], undefined>, v.DescriptionAction<{
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    }, string>]>;
    readonly size: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly pressReady: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly language: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly readingProgression: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", string>]>;
    readonly toc: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        readonly htmlPath: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        readonly sectionDepth: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>;
        readonly transformDocumentList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
        }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, string>]>;
        readonly transformSectionList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
        }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
            readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
            readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>, undefined>;
            readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
            }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, string>]>, undefined>;
            readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
            }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
        readonly '~types'?: {
            readonly input: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            };
            readonly output: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            };
            readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
        } | undefined;
    }, v.TitleAction<{
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    }, "TocConfig">]>, v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | boolean | {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    }, {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined>, v.DescriptionAction<{
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined, string>]>;
    /** @deprecated */
    readonly tocTitle: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.MetadataAction<string, {
        readonly deprecated: true;
    }>, v.DescriptionAction<string, string>]>;
    readonly cover: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly src: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly src: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: src">;
        };
        readonly '~standard': v.StandardProps<{
            src: string;
        }, {
            src: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            src: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                src: string;
            };
            readonly output: {
                src: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly name: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>;
        readonly htmlPath: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly name: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>, undefined>;
            readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }, {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
        readonly '~types'?: {
            readonly input: {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            };
            readonly output: {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }, "CoverConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }), {
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }>, v.DescriptionAction<{
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }, string>]>;
    readonly timeout: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.DescriptionAction<number, string>]>;
    readonly documentProcessor: v.SchemaWithPipe<readonly [v.GenericSchema<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor>, v.MetadataAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, {
        readonly typeString: "(option: import(\"@vivliostyle/vfm\").StringifyMarkdownOptions, metadata: import(\"@vivliostyle/vfm\").Metadata) => import(\"unified\").Processor";
    }>, v.DescriptionAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, string>]>;
    readonly vfm: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.LooseObjectSchema<{
        readonly style: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        readonly partial: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
        readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        readonly language: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        readonly replace: v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
            readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
            readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
            }>]>;
        }, undefined>, undefined>, v.DescriptionAction<({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[], string>]>;
        readonly hardLineBreaks: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
        readonly disableFormatHtml: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
        readonly math: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly style: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            readonly partial: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
            readonly language: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
            readonly replace: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
                readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                    readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                }>]>;
            }, undefined>, undefined>, v.DescriptionAction<({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[], string>]>, undefined>;
            readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
            readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
            readonly math: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, {
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue>;
        readonly '~types'?: {
            readonly input: {
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            };
            readonly output: {
                style?: string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            };
            readonly issue: v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue;
        } | undefined;
    }, v.TitleAction<{
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }, "VfmConfig">]>], undefined>, v.DescriptionAction<{
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }, string>]>;
    readonly image: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.CheckAction<string, `The specified image is not compatible with the CLI version ${any}. Please check the image version.`>, v.DescriptionAction<string, string>]>;
    /** @deprecated */
    readonly http: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.MetadataAction<boolean, {
        readonly deprecated: true;
    }>, v.DescriptionAction<boolean, string>]>;
    readonly viewer: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly viewerParam: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly browser: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", string>]>;
    readonly base: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.RegexAction<string, "Base path must start with a slash">, v.CheckAction<string, "Base path must not be root">, v.TransformAction<string, string>, v.DescriptionAction<string, string>]>;
    readonly server: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
        readonly host: v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>;
        readonly port: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>;
        readonly proxy: v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
            readonly typeString: "import(\"vite\").ProxyOptions";
        }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        }, string>]>;
        readonly allowedHosts: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly host: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
            readonly port: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>, undefined>;
            readonly proxy: v.OptionalSchema<v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
                readonly typeString: "import(\"vite\").ProxyOptions";
            }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            }, string>]>, undefined>;
            readonly allowedHosts: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }, {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>;
        readonly '~types'?: {
            readonly input: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            };
            readonly output: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>;
        } | undefined;
    }, v.TitleAction<{
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    }, "ServerConfig">]>], undefined>, v.DescriptionAction<{
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    }, string>]>;
    readonly static: v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.RegexAction<string, "Base path must start with a slash">, v.TransformAction<string, string>]>, v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>, v.DescriptionAction<{
        [x: string]: string[];
    }, string>, v.TransformAction<{
        [x: string]: string[];
    }, {
        [x: string]: string[];
    }>]>;
    readonly temporaryFilePrefix: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly vite: v.SchemaWithPipe<readonly [v.CustomSchema<vite.UserConfig, undefined>, v.MetadataAction<vite.UserConfig, {
        readonly typeString: "import(\"vite\").UserConfig";
    }>, v.DescriptionAction<vite.UserConfig, string>]>;
    readonly viteConfigFile: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly author: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, v.DescriptionAction<({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[], string>]>, undefined>;
        readonly entryContext: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
            }, {
                path: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
            readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
            readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
            readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly '~types'?: {
                readonly input: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
            }, {
                path: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
            readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
            readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
            readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly '~types'?: {
                readonly input: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[], ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[]>, v.DescriptionAction<({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[], string>]>, undefined>;
        readonly workspaceDir: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly includeAssets: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.MetadataAction<string[], {
            readonly deprecated: true;
        }>, v.DescriptionAction<string[], string>]>, undefined>;
        readonly copyAsset: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly includes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
            readonly excludes: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
            readonly includeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
            readonly excludeFileExtensions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly includes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
                readonly excludes: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
                readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
                readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.CheckAction<string[], string>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            }, {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>>;
            readonly '~types'?: {
                readonly input: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                };
                readonly output: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>;
            } | undefined;
        }, v.TitleAction<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, "CopyAssetConfig">]>], undefined>, v.DescriptionAction<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, string>]>, undefined>;
        readonly size: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly pressReady: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly language: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly readingProgression: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", string>]>, undefined>;
        readonly toc: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            readonly htmlPath: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            readonly sectionDepth: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>;
            readonly transformDocumentList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
            }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, string>]>;
            readonly transformSectionList: v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
            }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
                readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
                readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, string>]>, undefined>;
                readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, {
                    readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                    readonly typeReferences: readonly [v.GenericSchema<StructuredDocument>];
                }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, string>]>, undefined>;
                readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, {
                    readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                    readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection>];
                }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            }, {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
            readonly '~types'?: {
                readonly input: {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                };
                readonly output: {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                };
                readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
            } | undefined;
        }, v.TitleAction<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, "TocConfig">]>, v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined>, v.DescriptionAction<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined, string>]>, undefined>;
        readonly tocTitle: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.MetadataAction<string, {
            readonly deprecated: true;
        }>, v.DescriptionAction<string, string>]>, undefined>;
        readonly cover: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly src: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly src: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: src">;
            };
            readonly '~standard': v.StandardProps<{
                src: string;
            }, {
                src: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                src: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    src: string;
                };
                readonly output: {
                    src: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly name: v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>;
            readonly htmlPath: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly name: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.DescriptionAction<string, string>]>, undefined>;
                readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }, {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
            readonly '~types'?: {
                readonly input: {
                    name?: string | undefined;
                    htmlPath?: string | boolean | undefined;
                };
                readonly output: {
                    name?: string | undefined;
                    htmlPath?: string | boolean | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }, "CoverConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }), {
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }>, v.DescriptionAction<{
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }, string>]>, undefined>;
        readonly timeout: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.DescriptionAction<number, string>]>, undefined>;
        readonly documentProcessor: v.OptionalSchema<v.SchemaWithPipe<readonly [v.GenericSchema<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor>, v.MetadataAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, {
            readonly typeString: "(option: import(\"@vivliostyle/vfm\").StringifyMarkdownOptions, metadata: import(\"@vivliostyle/vfm\").Metadata) => import(\"unified\").Processor";
        }>, v.DescriptionAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, string>]>, undefined>;
        readonly vfm: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.LooseObjectSchema<{
            readonly style: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
            readonly partial: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
            readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            readonly language: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
            readonly replace: v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
                readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                    readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                }>]>;
            }, undefined>, undefined>, v.DescriptionAction<({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[], string>]>;
            readonly hardLineBreaks: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
            readonly disableFormatHtml: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
            readonly math: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly style: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
                readonly partial: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
                readonly language: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
                readonly replace: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.LooseObjectSchema<{
                    readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                    readonly match: v.SchemaWithPipe<readonly [v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                        readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                    }>]>;
                }, undefined>, undefined>, v.DescriptionAction<({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[], string>]>, undefined>;
                readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
                readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
                readonly math: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }, {
                style?: string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                style?: string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }, v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue>;
            readonly '~types'?: {
                readonly input: {
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    title?: string | undefined;
                    language?: string | undefined;
                    replace?: ({
                        test: RegExp;
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                };
                readonly output: {
                    style?: string[] | undefined;
                    partial?: boolean | undefined;
                    title?: string | undefined;
                    language?: string | undefined;
                    replace?: ({
                        test: RegExp;
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                };
                readonly issue: v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue;
            } | undefined;
        }, v.TitleAction<{
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, "VfmConfig">]>], undefined>, v.DescriptionAction<{
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, string>]>, undefined>;
        readonly image: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.CheckAction<string, `The specified image is not compatible with the CLI version ${any}. Please check the image version.`>, v.DescriptionAction<string, string>]>, undefined>;
        readonly http: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.MetadataAction<boolean, {
            readonly deprecated: true;
        }>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly viewer: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly viewerParam: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly browser: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", string>]>, undefined>;
        readonly base: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.RegexAction<string, "Base path must start with a slash">, v.CheckAction<string, "Base path must not be root">, v.TransformAction<string, string>, v.DescriptionAction<string, string>]>, undefined>;
        readonly server: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
            readonly host: v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>;
            readonly port: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>;
            readonly proxy: v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
                readonly typeString: "import(\"vite\").ProxyOptions";
            }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            }, string>]>;
            readonly allowedHosts: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly host: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
                readonly port: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>, undefined>;
                readonly proxy: v.OptionalSchema<v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<readonly [v.CustomSchema<vite.ProxyOptions, undefined>, v.MetadataAction<vite.ProxyOptions, {
                    readonly typeString: "import(\"vite\").ProxyOptions";
                }>]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.DescriptionAction<{
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                }, string>]>, undefined>;
                readonly allowedHosts: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<boolean | string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            }, {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>;
            readonly '~types'?: {
                readonly input: {
                    host?: string | boolean | undefined;
                    port?: number | undefined;
                    proxy?: {
                        [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                    } | undefined;
                    allowedHosts?: boolean | string[] | undefined;
                };
                readonly output: {
                    host?: string | boolean | undefined;
                    port?: number | undefined;
                    proxy?: {
                        [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                    } | undefined;
                    allowedHosts?: boolean | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>;
            } | undefined;
        }, v.TitleAction<{
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }, "ServerConfig">]>], undefined>, v.DescriptionAction<{
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        }, string>]>, undefined>;
        readonly static: v.OptionalSchema<v.SchemaWithPipe<readonly [v.RecordSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.RegexAction<string, "Base path must start with a slash">, v.TransformAction<string, string>]>, v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>]>, undefined>, v.DescriptionAction<{
            [x: string]: string[];
        }, string>, v.TransformAction<{
            [x: string]: string[];
        }, {
            [x: string]: string[];
        }>]>, undefined>;
        readonly temporaryFilePrefix: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly vite: v.OptionalSchema<v.SchemaWithPipe<readonly [v.CustomSchema<vite.UserConfig, undefined>, v.MetadataAction<vite.UserConfig, {
            readonly typeString: "import(\"vite\").UserConfig";
        }>, v.DescriptionAction<vite.UserConfig, string>]>, undefined>;
        readonly viteConfigFile: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }, {
        title?: string | undefined;
        author?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        entryContext?: string | undefined;
        output?: ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: string[];
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        title?: string | undefined;
        author?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        entryContext?: string | undefined;
        output?: ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: string[];
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }, v.BaseIssue<unknown> | v.ObjectIssue | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.CheckIssue<string[]> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6> | v.UnionIssue<v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>> | v.InstanceIssue | v.UnionIssue<v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue> | v.CheckIssue<string> | v.RegexIssue<string> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>>;
    readonly '~types'?: {
        readonly input: {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        };
        readonly output: {
            title?: string | undefined;
            author?: string | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            entryContext?: string | undefined;
            output?: ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            } & {
                format: OutputFormat;
            })[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: string[];
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        };
        readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.CheckIssue<string[]> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.CheckIssue<string[]>> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6> | v.UnionIssue<v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NumberIssue | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>> | v.InstanceIssue | v.UnionIssue<v.BaseIssue<unknown> | v.LooseObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.BooleanIssue | v.InstanceIssue> | v.CheckIssue<string> | v.RegexIssue<string> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.NumberIssue | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.RecordIssue | v.CustomIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.CustomIssue> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.BooleanIssue>>;
    } | undefined;
}], undefined>, v.TitleAction<{
    entry: ({
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[];
} & {
    title?: string | undefined;
    author?: string | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    entryContext?: string | undefined;
    output?: ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[] | undefined;
    workspaceDir?: string | undefined;
    includeAssets?: string[] | undefined;
    copyAsset?: {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    } | undefined;
    size?: string | undefined;
    pressReady?: boolean | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    toc?: {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined;
    tocTitle?: string | undefined;
    cover?: ({
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }) | undefined;
    timeout?: number | undefined;
    documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
    vfm?: ({
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }) | undefined;
    image?: string | undefined;
    http?: boolean | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
    base?: string | undefined;
    server?: {
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    } | undefined;
    static?: {
        [x: string]: string[];
    } | undefined;
    temporaryFilePrefix?: string | undefined;
    vite?: vite.UserConfig | undefined;
    viteConfigFile?: string | boolean | undefined;
}, "BuildTask">]>], undefined>, v.TransformAction<({
    entry: ({
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[];
} & {
    title?: string | undefined;
    author?: string | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    entryContext?: string | undefined;
    output?: ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[] | undefined;
    workspaceDir?: string | undefined;
    includeAssets?: string[] | undefined;
    copyAsset?: {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    } | undefined;
    size?: string | undefined;
    pressReady?: boolean | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    toc?: {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined;
    tocTitle?: string | undefined;
    cover?: ({
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }) | undefined;
    timeout?: number | undefined;
    documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
    vfm?: ({
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }) | undefined;
    image?: string | undefined;
    http?: boolean | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
    base?: string | undefined;
    server?: {
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    } | undefined;
    static?: {
        [x: string]: string[];
    } | undefined;
    temporaryFilePrefix?: string | undefined;
    vite?: vite.UserConfig | undefined;
    viteConfigFile?: string | boolean | undefined;
}) | ({
    entry: ({
        rel: "contents";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        path?: string | undefined;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    } | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string[] | undefined;
    })[];
} & {
    title?: string | undefined;
    author?: string | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    entryContext?: string | undefined;
    output?: ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[] | undefined;
    workspaceDir?: string | undefined;
    includeAssets?: string[] | undefined;
    copyAsset?: {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    } | undefined;
    size?: string | undefined;
    pressReady?: boolean | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    toc?: {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined;
    tocTitle?: string | undefined;
    cover?: ({
        src: string;
    } & {
        name?: string | undefined;
        htmlPath?: string | boolean | undefined;
    }) | undefined;
    timeout?: number | undefined;
    documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
    vfm?: ({
        style?: string[] | undefined;
        partial?: boolean | undefined;
        title?: string | undefined;
        language?: string | undefined;
        replace?: ({
            test: RegExp;
            match: (result: RegExpMatchArray, h: any) => Object | string;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }) | undefined;
    image?: string | undefined;
    http?: boolean | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
    base?: string | undefined;
    server?: {
        host?: string | boolean | undefined;
        port?: number | undefined;
        proxy?: {
            [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
        } | undefined;
        allowedHosts?: boolean | string[] | undefined;
    } | undefined;
    static?: {
        [x: string]: string[];
    } | undefined;
    temporaryFilePrefix?: string | undefined;
    vite?: vite.UserConfig | undefined;
    viteConfigFile?: string | boolean | undefined;
})[], {
    tasks: ParsedBuildTask[];
    inlineOptions: InlineOptions;
}>, v.TitleAction<{
    tasks: ParsedBuildTask[];
    inlineOptions: InlineOptions;
}, "VivliostyleConfigSchema">]>;
/**
 * @see https://github.com/vivliostyle/vivliostyle-cli/blob/main/docs/config.md
 */
type VivliostyleConfigSchema = v.InferInput<typeof VivliostyleConfigSchema>;
type ParsedVivliostyleConfigSchema = v.InferOutput<typeof VivliostyleConfigSchema>;
type InputFormat = 'markdown' | 'webbook' | 'pub-manifest' | 'epub' | 'epub-opf';
declare const VivliostyleInlineConfig: v.SchemaWithPipe<readonly [Omit<v.ObjectSchema<{
    readonly cwd: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly config: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly configData: v.SchemaWithPipe<readonly [v.CustomSchema<({
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    } & {
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }) | ({
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    } & {
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    })[] | null | undefined, undefined>, v.MetadataAction<({
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    } & {
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }) | ({
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    } & {
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    })[] | null | undefined, {
        readonly typeString: "VivliostyleConfigSchema";
    }>, v.DescriptionAction<({
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    } & {
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }) | ({
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    } & {
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    })[] | null | undefined, string>]>;
    readonly input: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.TransformAction<string, {
        format: InputFormat;
        entry: string;
    }>, v.DescriptionAction<{
        format: InputFormat;
        entry: string;
    }, string>]>;
    readonly output: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
        }, {
            path: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
        readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
        readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
        readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly '~types'?: {
            readonly input: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
        };
        readonly '~standard': v.StandardProps<{
            path: string;
        }, {
            path: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
        readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
        readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
        readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly '~types'?: {
            readonly input: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[], ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[]>, v.DescriptionAction<({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[], string>]>;
    readonly theme: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
        };
        readonly '~standard': v.StandardProps<{
            specifier: string;
        }, {
            specifier: string;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly '~types'?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        };
        readonly '~standard': v.StandardProps<{
            import?: string | string[] | undefined;
        }, {
            import?: string[] | undefined;
        }>;
        readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
            import?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
        readonly '~types'?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string[] | undefined;
    }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    }))[], ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[]>]>, v.DescriptionAction<({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[], string>]>;
    readonly size: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly cropMarks: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly bleed: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly cropOffset: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly css: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly style: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly userStyle: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly singleDoc: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly quick: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly pressReady: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly title: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly author: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly language: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly readingProgression: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", string>]>;
    readonly timeout: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.DescriptionAction<number, string>]>;
    readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
    readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
    readonly preflightOption: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
    readonly sandbox: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly executableBrowser: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly image: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly viewer: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly viewerParam: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly browser: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", string>]>;
    readonly proxyServer: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly proxyBypass: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly proxyUser: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly proxyPass: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
    readonly logLevel: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"silent", undefined>, v.LiteralSchema<"info", undefined>, v.LiteralSchema<"verbose", undefined>, v.LiteralSchema<"debug", undefined>], undefined>, v.DescriptionAction<"silent" | "info" | "verbose" | "debug", string>]>;
    readonly ignoreHttpsErrors: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly openViewer: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly enableStaticServe: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly enableViewerStartPage: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
    readonly vite: v.SchemaWithPipe<readonly [v.CustomSchema<vite.UserConfig, undefined>, v.MetadataAction<vite.UserConfig, {
        readonly typeString: "import(\"vite\").UserConfig";
    }>, v.DescriptionAction<vite.UserConfig, string>]>;
    readonly viteConfigFile: v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>;
    readonly host: v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>;
    readonly port: v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>;
    readonly logger: v.SchemaWithPipe<readonly [v.CustomSchema<LoggerInterface, undefined>, v.MetadataAction<LoggerInterface, {
        readonly typeString: "LoggerInterface";
    }>, v.DescriptionAction<LoggerInterface, string>]>;
    readonly disableServerStartup: v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>;
}, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
    readonly entries: {
        readonly cwd: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly config: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly configData: v.OptionalSchema<v.SchemaWithPipe<readonly [v.CustomSchema<({
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        } & {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        }) | ({
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        } & {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        })[] | null | undefined, undefined>, v.MetadataAction<({
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        } & {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        }) | ({
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        } & {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        })[] | null | undefined, {
            readonly typeString: "VivliostyleConfigSchema";
        }>, v.DescriptionAction<({
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        } & {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        }) | ({
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        } & {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        })[] | null | undefined, string>]>, undefined>;
        readonly input: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.TransformAction<string, {
            format: InputFormat;
            entry: string;
        }>, v.DescriptionAction<{
            format: InputFormat;
            entry: string;
        }, string>]>, undefined>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
            }, {
                path: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
            readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
            readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
            readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly '~types'?: {
                readonly input: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: path">;
            };
            readonly '~standard': v.StandardProps<{
                path: string;
            }, {
                path: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>;
            readonly renderMode: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>;
            readonly preflight: v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>;
            readonly preflightOption: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"pdf", undefined>, v.LiteralSchema<"epub", undefined>, v.LiteralSchema<"webpub", undefined>], undefined>, v.DescriptionAction<"pdf" | "epub" | "webpub", string>]>, undefined>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly '~types'?: {
                readonly input: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[], ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[]>, v.DescriptionAction<({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[], string>]>, undefined>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<readonly [v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, "Missing required field: specifier">;
            };
            readonly '~standard': v.StandardProps<{
                specifier: string;
            }, {
                specifier: string;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly '~types'?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>;
        }, undefined>, "~types" | "~run" | "~standard" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
            };
            readonly '~standard': v.StandardProps<{
                import?: string | string[] | undefined;
            }, {
                import?: string[] | undefined;
            }>;
            readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
                import?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>;
            readonly '~types'?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string[] | undefined;
        }, "ThemeConfig">]>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        }))[], ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[]>]>, v.DescriptionAction<({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[], string>]>, undefined>;
        readonly size: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly cropMarks: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly bleed: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly cropOffset: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly css: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly style: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly userStyle: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly singleDoc: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly quick: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly pressReady: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly author: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly language: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly readingProgression: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", string>]>, undefined>;
        readonly timeout: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.DescriptionAction<number, string>]>, undefined>;
        readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", string>]>, undefined>;
        readonly preflight: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", string>]>, undefined>;
        readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.TransformAction<string | string[], string[]>, v.DescriptionAction<string[], string>]>, undefined>;
        readonly sandbox: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly executableBrowser: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly image: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly viewer: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly viewerParam: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly browser: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", string>]>, undefined>;
        readonly proxyServer: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly proxyBypass: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly proxyUser: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly proxyPass: v.OptionalSchema<v.SchemaWithPipe<readonly [v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, string>]>, undefined>;
        readonly logLevel: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.LiteralSchema<"silent", undefined>, v.LiteralSchema<"info", undefined>, v.LiteralSchema<"verbose", undefined>, v.LiteralSchema<"debug", undefined>], undefined>, v.DescriptionAction<"silent" | "info" | "verbose" | "debug", string>]>, undefined>;
        readonly ignoreHttpsErrors: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly openViewer: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly enableStaticServe: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly enableViewerStartPage: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
        readonly vite: v.OptionalSchema<v.SchemaWithPipe<readonly [v.CustomSchema<vite.UserConfig, undefined>, v.MetadataAction<vite.UserConfig, {
            readonly typeString: "import(\"vite\").UserConfig";
        }>, v.DescriptionAction<vite.UserConfig, string>]>, undefined>;
        readonly viteConfigFile: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
        readonly host: v.OptionalSchema<v.SchemaWithPipe<readonly [v.UnionSchema<[v.BooleanSchema<undefined>, v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean, string>]>, undefined>;
        readonly port: v.OptionalSchema<v.SchemaWithPipe<readonly [v.NumberSchema<undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 65535, undefined>, v.DescriptionAction<number, string>]>, undefined>;
        readonly logger: v.OptionalSchema<v.SchemaWithPipe<readonly [v.CustomSchema<LoggerInterface, undefined>, v.MetadataAction<LoggerInterface, {
            readonly typeString: "LoggerInterface";
        }>, v.DescriptionAction<LoggerInterface, string>]>, undefined>;
        readonly disableServerStartup: v.OptionalSchema<v.SchemaWithPipe<readonly [v.BooleanSchema<undefined>, v.DescriptionAction<boolean, string>]>, undefined>;
    };
    readonly '~standard': v.StandardProps<{
        cwd?: string | undefined;
        config?: string | undefined;
        configData?: ({
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        } & {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        }) | ({
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        } & {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        })[] | null | undefined;
        input?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        size?: string | undefined;
        cropMarks?: boolean | undefined;
        bleed?: string | undefined;
        cropOffset?: string | undefined;
        css?: string | undefined;
        style?: string | undefined;
        userStyle?: string | undefined;
        singleDoc?: boolean | undefined;
        quick?: boolean | undefined;
        pressReady?: boolean | undefined;
        title?: string | undefined;
        author?: string | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        timeout?: number | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string | string[] | undefined;
        sandbox?: boolean | undefined;
        executableBrowser?: string | undefined;
        image?: string | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        proxyServer?: string | undefined;
        proxyBypass?: string | undefined;
        proxyUser?: string | undefined;
        proxyPass?: string | undefined;
        logLevel?: "silent" | "info" | "verbose" | "debug" | undefined;
        ignoreHttpsErrors?: boolean | undefined;
        openViewer?: boolean | undefined;
        enableStaticServe?: boolean | undefined;
        enableViewerStartPage?: boolean | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
        host?: string | boolean | undefined;
        port?: number | undefined;
        logger?: LoggerInterface | undefined;
        disableServerStartup?: boolean | undefined;
    }, {
        cwd?: string | undefined;
        config?: string | undefined;
        configData?: ({
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        } & {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        }) | ({
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        } & {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        })[] | null | undefined;
        input?: {
            format: InputFormat;
            entry: string;
        } | undefined;
        output?: ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[] | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        size?: string | undefined;
        cropMarks?: boolean | undefined;
        bleed?: string | undefined;
        cropOffset?: string | undefined;
        css?: string | undefined;
        style?: string | undefined;
        userStyle?: string | undefined;
        singleDoc?: boolean | undefined;
        quick?: boolean | undefined;
        pressReady?: boolean | undefined;
        title?: string | undefined;
        author?: string | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        timeout?: number | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
        sandbox?: boolean | undefined;
        executableBrowser?: string | undefined;
        image?: string | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        proxyServer?: string | undefined;
        proxyBypass?: string | undefined;
        proxyUser?: string | undefined;
        proxyPass?: string | undefined;
        logLevel?: "silent" | "info" | "verbose" | "debug" | undefined;
        ignoreHttpsErrors?: boolean | undefined;
        openViewer?: boolean | undefined;
        enableStaticServe?: boolean | undefined;
        enableViewerStartPage?: boolean | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
        host?: string | boolean | undefined;
        port?: number | undefined;
        logger?: LoggerInterface | undefined;
        disableServerStartup?: boolean | undefined;
    }>;
    readonly '~run': (dataset: v.UnknownDataset, config: v.Config<v.BaseIssue<unknown>>) => v.OutputDataset<{
        cwd?: string | undefined;
        config?: string | undefined;
        configData?: ({
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        } & {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        }) | ({
            entry: (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[] | undefined) & (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                rel: "contents";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                path?: string | undefined;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            } | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            })[]);
        } & {
            title?: string | undefined;
            author?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            entryContext?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            cover?: string | ({
                src: string;
            } & {
                name?: string | undefined;
                htmlPath?: string | boolean | undefined;
            }) | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                title?: string | undefined;
                language?: string | undefined;
                replace?: ({
                    test: RegExp;
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            base?: string | undefined;
            server?: {
                host?: string | boolean | undefined;
                port?: number | undefined;
                proxy?: {
                    [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                } | undefined;
                allowedHosts?: boolean | string[] | undefined;
            } | undefined;
            static?: {
                [x: string]: (string | string[] | undefined) & (string | string[]);
            } | undefined;
            temporaryFilePrefix?: string | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
        })[] | null | undefined;
        input?: {
            format: InputFormat;
            entry: string;
        } | undefined;
        output?: ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        } & {
            format: OutputFormat;
        })[] | undefined;
        theme?: ({
            specifier: string;
        } & {
            import?: string[] | undefined;
        })[] | undefined;
        size?: string | undefined;
        cropMarks?: boolean | undefined;
        bleed?: string | undefined;
        cropOffset?: string | undefined;
        css?: string | undefined;
        style?: string | undefined;
        userStyle?: string | undefined;
        singleDoc?: boolean | undefined;
        quick?: boolean | undefined;
        pressReady?: boolean | undefined;
        title?: string | undefined;
        author?: string | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        timeout?: number | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
        sandbox?: boolean | undefined;
        executableBrowser?: string | undefined;
        image?: string | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        proxyServer?: string | undefined;
        proxyBypass?: string | undefined;
        proxyUser?: string | undefined;
        proxyPass?: string | undefined;
        logLevel?: "silent" | "info" | "verbose" | "debug" | undefined;
        ignoreHttpsErrors?: boolean | undefined;
        openViewer?: boolean | undefined;
        enableStaticServe?: boolean | undefined;
        enableViewerStartPage?: boolean | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
        host?: string | boolean | undefined;
        port?: number | undefined;
        logger?: LoggerInterface | undefined;
        disableServerStartup?: boolean | undefined;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.CustomIssue>;
    readonly '~types'?: {
        readonly input: {
            cwd?: string | undefined;
            config?: string | undefined;
            configData?: ({
                entry: (string | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                } | (string | {
                    rel: "contents";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                    pageCounterReset?: number | undefined;
                } | {
                    rel: "cover";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    imageSrc?: string | undefined;
                    imageAlt?: string | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                } | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                })[] | undefined) & (string | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                } | (string | {
                    rel: "contents";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                    pageCounterReset?: number | undefined;
                } | {
                    rel: "cover";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    imageSrc?: string | undefined;
                    imageAlt?: string | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                } | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                })[]);
            } & {
                title?: string | undefined;
                author?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                entryContext?: string | undefined;
                output?: string | ({
                    path: string;
                } & {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                }) | (string | ({
                    path: string;
                } & {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                }))[] | undefined;
                workspaceDir?: string | undefined;
                includeAssets?: string | string[] | undefined;
                copyAsset?: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                } | undefined;
                size?: string | undefined;
                pressReady?: boolean | undefined;
                language?: string | undefined;
                readingProgression?: "ltr" | "rtl" | undefined;
                toc?: string | boolean | {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                } | undefined;
                tocTitle?: string | undefined;
                cover?: string | ({
                    src: string;
                } & {
                    name?: string | undefined;
                    htmlPath?: string | boolean | undefined;
                }) | undefined;
                timeout?: number | undefined;
                documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
                vfm?: ({
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    title?: string | undefined;
                    language?: string | undefined;
                    replace?: ({
                        test: RegExp;
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                }) | undefined;
                image?: string | undefined;
                http?: boolean | undefined;
                viewer?: string | undefined;
                viewerParam?: string | undefined;
                browser?: "chromium" | "firefox" | "webkit" | undefined;
                base?: string | undefined;
                server?: {
                    host?: string | boolean | undefined;
                    port?: number | undefined;
                    proxy?: {
                        [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                    } | undefined;
                    allowedHosts?: boolean | string[] | undefined;
                } | undefined;
                static?: {
                    [x: string]: (string | string[] | undefined) & (string | string[]);
                } | undefined;
                temporaryFilePrefix?: string | undefined;
                vite?: vite.UserConfig | undefined;
                viteConfigFile?: string | boolean | undefined;
            }) | ({
                entry: (string | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                } | (string | {
                    rel: "contents";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                    pageCounterReset?: number | undefined;
                } | {
                    rel: "cover";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    imageSrc?: string | undefined;
                    imageAlt?: string | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                } | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                })[] | undefined) & (string | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                } | (string | {
                    rel: "contents";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                    pageCounterReset?: number | undefined;
                } | {
                    rel: "cover";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    imageSrc?: string | undefined;
                    imageAlt?: string | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                } | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                })[]);
            } & {
                title?: string | undefined;
                author?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                entryContext?: string | undefined;
                output?: string | ({
                    path: string;
                } & {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                }) | (string | ({
                    path: string;
                } & {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                }))[] | undefined;
                workspaceDir?: string | undefined;
                includeAssets?: string | string[] | undefined;
                copyAsset?: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                } | undefined;
                size?: string | undefined;
                pressReady?: boolean | undefined;
                language?: string | undefined;
                readingProgression?: "ltr" | "rtl" | undefined;
                toc?: string | boolean | {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                } | undefined;
                tocTitle?: string | undefined;
                cover?: string | ({
                    src: string;
                } & {
                    name?: string | undefined;
                    htmlPath?: string | boolean | undefined;
                }) | undefined;
                timeout?: number | undefined;
                documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
                vfm?: ({
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    title?: string | undefined;
                    language?: string | undefined;
                    replace?: ({
                        test: RegExp;
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                }) | undefined;
                image?: string | undefined;
                http?: boolean | undefined;
                viewer?: string | undefined;
                viewerParam?: string | undefined;
                browser?: "chromium" | "firefox" | "webkit" | undefined;
                base?: string | undefined;
                server?: {
                    host?: string | boolean | undefined;
                    port?: number | undefined;
                    proxy?: {
                        [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                    } | undefined;
                    allowedHosts?: boolean | string[] | undefined;
                } | undefined;
                static?: {
                    [x: string]: (string | string[] | undefined) & (string | string[]);
                } | undefined;
                temporaryFilePrefix?: string | undefined;
                vite?: vite.UserConfig | undefined;
                viteConfigFile?: string | boolean | undefined;
            })[] | null | undefined;
            input?: string | undefined;
            output?: string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            size?: string | undefined;
            cropMarks?: boolean | undefined;
            bleed?: string | undefined;
            cropOffset?: string | undefined;
            css?: string | undefined;
            style?: string | undefined;
            userStyle?: string | undefined;
            singleDoc?: boolean | undefined;
            quick?: boolean | undefined;
            pressReady?: boolean | undefined;
            title?: string | undefined;
            author?: string | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            timeout?: number | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string | string[] | undefined;
            sandbox?: boolean | undefined;
            executableBrowser?: string | undefined;
            image?: string | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            proxyServer?: string | undefined;
            proxyBypass?: string | undefined;
            proxyUser?: string | undefined;
            proxyPass?: string | undefined;
            logLevel?: "silent" | "info" | "verbose" | "debug" | undefined;
            ignoreHttpsErrors?: boolean | undefined;
            openViewer?: boolean | undefined;
            enableStaticServe?: boolean | undefined;
            enableViewerStartPage?: boolean | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
            host?: string | boolean | undefined;
            port?: number | undefined;
            logger?: LoggerInterface | undefined;
            disableServerStartup?: boolean | undefined;
        };
        readonly output: {
            cwd?: string | undefined;
            config?: string | undefined;
            configData?: ({
                entry: (string | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                } | (string | {
                    rel: "contents";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                    pageCounterReset?: number | undefined;
                } | {
                    rel: "cover";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    imageSrc?: string | undefined;
                    imageAlt?: string | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                } | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                })[] | undefined) & (string | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                } | (string | {
                    rel: "contents";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                    pageCounterReset?: number | undefined;
                } | {
                    rel: "cover";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    imageSrc?: string | undefined;
                    imageAlt?: string | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                } | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                })[]);
            } & {
                title?: string | undefined;
                author?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                entryContext?: string | undefined;
                output?: string | ({
                    path: string;
                } & {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                }) | (string | ({
                    path: string;
                } & {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                }))[] | undefined;
                workspaceDir?: string | undefined;
                includeAssets?: string | string[] | undefined;
                copyAsset?: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                } | undefined;
                size?: string | undefined;
                pressReady?: boolean | undefined;
                language?: string | undefined;
                readingProgression?: "ltr" | "rtl" | undefined;
                toc?: string | boolean | {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                } | undefined;
                tocTitle?: string | undefined;
                cover?: string | ({
                    src: string;
                } & {
                    name?: string | undefined;
                    htmlPath?: string | boolean | undefined;
                }) | undefined;
                timeout?: number | undefined;
                documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
                vfm?: ({
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    title?: string | undefined;
                    language?: string | undefined;
                    replace?: ({
                        test: RegExp;
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                }) | undefined;
                image?: string | undefined;
                http?: boolean | undefined;
                viewer?: string | undefined;
                viewerParam?: string | undefined;
                browser?: "chromium" | "firefox" | "webkit" | undefined;
                base?: string | undefined;
                server?: {
                    host?: string | boolean | undefined;
                    port?: number | undefined;
                    proxy?: {
                        [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                    } | undefined;
                    allowedHosts?: boolean | string[] | undefined;
                } | undefined;
                static?: {
                    [x: string]: (string | string[] | undefined) & (string | string[]);
                } | undefined;
                temporaryFilePrefix?: string | undefined;
                vite?: vite.UserConfig | undefined;
                viteConfigFile?: string | boolean | undefined;
            }) | ({
                entry: (string | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                } | (string | {
                    rel: "contents";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                    pageCounterReset?: number | undefined;
                } | {
                    rel: "cover";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    imageSrc?: string | undefined;
                    imageAlt?: string | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                } | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                })[] | undefined) & (string | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                } | (string | {
                    rel: "contents";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                    pageCounterReset?: number | undefined;
                } | {
                    rel: "cover";
                    path?: string | undefined;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    imageSrc?: string | undefined;
                    imageAlt?: string | undefined;
                    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                } | {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                })[]);
            } & {
                title?: string | undefined;
                author?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                entryContext?: string | undefined;
                output?: string | ({
                    path: string;
                } & {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                }) | (string | ({
                    path: string;
                } & {
                    format?: "pdf" | "epub" | "webpub" | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                }))[] | undefined;
                workspaceDir?: string | undefined;
                includeAssets?: string | string[] | undefined;
                copyAsset?: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                } | undefined;
                size?: string | undefined;
                pressReady?: boolean | undefined;
                language?: string | undefined;
                readingProgression?: "ltr" | "rtl" | undefined;
                toc?: string | boolean | {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                } | undefined;
                tocTitle?: string | undefined;
                cover?: string | ({
                    src: string;
                } & {
                    name?: string | undefined;
                    htmlPath?: string | boolean | undefined;
                }) | undefined;
                timeout?: number | undefined;
                documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
                vfm?: ({
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    title?: string | undefined;
                    language?: string | undefined;
                    replace?: ({
                        test: RegExp;
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                }) | undefined;
                image?: string | undefined;
                http?: boolean | undefined;
                viewer?: string | undefined;
                viewerParam?: string | undefined;
                browser?: "chromium" | "firefox" | "webkit" | undefined;
                base?: string | undefined;
                server?: {
                    host?: string | boolean | undefined;
                    port?: number | undefined;
                    proxy?: {
                        [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
                    } | undefined;
                    allowedHosts?: boolean | string[] | undefined;
                } | undefined;
                static?: {
                    [x: string]: (string | string[] | undefined) & (string | string[]);
                } | undefined;
                temporaryFilePrefix?: string | undefined;
                vite?: vite.UserConfig | undefined;
                viteConfigFile?: string | boolean | undefined;
            })[] | null | undefined;
            input?: {
                format: InputFormat;
                entry: string;
            } | undefined;
            output?: ({
                path: string;
            } & {
                format?: "pdf" | "epub" | "webpub" | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            } & {
                format: OutputFormat;
            })[] | undefined;
            theme?: ({
                specifier: string;
            } & {
                import?: string[] | undefined;
            })[] | undefined;
            size?: string | undefined;
            cropMarks?: boolean | undefined;
            bleed?: string | undefined;
            cropOffset?: string | undefined;
            css?: string | undefined;
            style?: string | undefined;
            userStyle?: string | undefined;
            singleDoc?: boolean | undefined;
            quick?: boolean | undefined;
            pressReady?: boolean | undefined;
            title?: string | undefined;
            author?: string | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            timeout?: number | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
            sandbox?: boolean | undefined;
            executableBrowser?: string | undefined;
            image?: string | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
            proxyServer?: string | undefined;
            proxyBypass?: string | undefined;
            proxyUser?: string | undefined;
            proxyPass?: string | undefined;
            logLevel?: "silent" | "info" | "verbose" | "debug" | undefined;
            ignoreHttpsErrors?: boolean | undefined;
            openViewer?: boolean | undefined;
            enableStaticServe?: boolean | undefined;
            enableViewerStartPage?: boolean | undefined;
            vite?: vite.UserConfig | undefined;
            viteConfigFile?: string | boolean | undefined;
            host?: string | boolean | undefined;
            port?: number | undefined;
            logger?: LoggerInterface | undefined;
            disableServerStartup?: boolean | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue>>> | v.UnionIssue<v.LiteralIssue> | v.NumberIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.ArrayIssue | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.BooleanIssue | v.MinValueIssue<number, 0> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.MaxValueIssue<number, 65535> | v.CustomIssue;
    } | undefined;
}, v.CheckAction<{
    cwd?: string | undefined;
    config?: string | undefined;
    configData?: ({
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    } & {
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }) | ({
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    } & {
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    })[] | null | undefined;
    input?: {
        format: InputFormat;
        entry: string;
    } | undefined;
    output?: ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[] | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    size?: string | undefined;
    cropMarks?: boolean | undefined;
    bleed?: string | undefined;
    cropOffset?: string | undefined;
    css?: string | undefined;
    style?: string | undefined;
    userStyle?: string | undefined;
    singleDoc?: boolean | undefined;
    quick?: boolean | undefined;
    pressReady?: boolean | undefined;
    title?: string | undefined;
    author?: string | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    timeout?: number | undefined;
    renderMode?: "local" | "docker" | undefined;
    preflight?: "press-ready" | "press-ready-local" | undefined;
    preflightOption?: string[] | undefined;
    sandbox?: boolean | undefined;
    executableBrowser?: string | undefined;
    image?: string | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
    proxyServer?: string | undefined;
    proxyBypass?: string | undefined;
    proxyUser?: string | undefined;
    proxyPass?: string | undefined;
    logLevel?: "silent" | "info" | "verbose" | "debug" | undefined;
    ignoreHttpsErrors?: boolean | undefined;
    openViewer?: boolean | undefined;
    enableStaticServe?: boolean | undefined;
    enableViewerStartPage?: boolean | undefined;
    vite?: vite.UserConfig | undefined;
    viteConfigFile?: string | boolean | undefined;
    host?: string | boolean | undefined;
    port?: number | undefined;
    logger?: LoggerInterface | undefined;
    disableServerStartup?: boolean | undefined;
}, "Exporting webpub format from EPUB or OPF file is not supported.">, v.CheckAction<{
    cwd?: string | undefined;
    config?: string | undefined;
    configData?: ({
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    } & {
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }) | ({
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    } & {
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    })[] | null | undefined;
    input?: {
        format: InputFormat;
        entry: string;
    } | undefined;
    output?: ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[] | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    size?: string | undefined;
    cropMarks?: boolean | undefined;
    bleed?: string | undefined;
    cropOffset?: string | undefined;
    css?: string | undefined;
    style?: string | undefined;
    userStyle?: string | undefined;
    singleDoc?: boolean | undefined;
    quick?: boolean | undefined;
    pressReady?: boolean | undefined;
    title?: string | undefined;
    author?: string | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    timeout?: number | undefined;
    renderMode?: "local" | "docker" | undefined;
    preflight?: "press-ready" | "press-ready-local" | undefined;
    preflightOption?: string[] | undefined;
    sandbox?: boolean | undefined;
    executableBrowser?: string | undefined;
    image?: string | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
    proxyServer?: string | undefined;
    proxyBypass?: string | undefined;
    proxyUser?: string | undefined;
    proxyPass?: string | undefined;
    logLevel?: "silent" | "info" | "verbose" | "debug" | undefined;
    ignoreHttpsErrors?: boolean | undefined;
    openViewer?: boolean | undefined;
    enableStaticServe?: boolean | undefined;
    enableViewerStartPage?: boolean | undefined;
    vite?: vite.UserConfig | undefined;
    viteConfigFile?: string | boolean | undefined;
    host?: string | boolean | undefined;
    port?: number | undefined;
    logger?: LoggerInterface | undefined;
    disableServerStartup?: boolean | undefined;
}, "Exporting EPUB format from EPUB or OPF file is not supported.">, v.TitleAction<{
    cwd?: string | undefined;
    config?: string | undefined;
    configData?: ({
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    } & {
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    }) | ({
        entry: (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[] | undefined) & (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            rel: "contents";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            path?: string | undefined;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        } | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        })[]);
    } & {
        title?: string | undefined;
        author?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        entryContext?: string | undefined;
        output?: string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: "pdf" | "epub" | "webpub" | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        cover?: string | ({
            src: string;
        } & {
            name?: string | undefined;
            htmlPath?: string | boolean | undefined;
        }) | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            title?: string | undefined;
            language?: string | undefined;
            replace?: ({
                test: RegExp;
                match: (result: RegExpMatchArray, h: any) => Object | string;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
        base?: string | undefined;
        server?: {
            host?: string | boolean | undefined;
            port?: number | undefined;
            proxy?: {
                [x: string]: (string | vite.ProxyOptions | undefined) & (string | vite.ProxyOptions);
            } | undefined;
            allowedHosts?: boolean | string[] | undefined;
        } | undefined;
        static?: {
            [x: string]: (string | string[] | undefined) & (string | string[]);
        } | undefined;
        temporaryFilePrefix?: string | undefined;
        vite?: vite.UserConfig | undefined;
        viteConfigFile?: string | boolean | undefined;
    })[] | null | undefined;
    input?: {
        format: InputFormat;
        entry: string;
    } | undefined;
    output?: ({
        path: string;
    } & {
        format?: "pdf" | "epub" | "webpub" | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    } & {
        format: OutputFormat;
    })[] | undefined;
    theme?: ({
        specifier: string;
    } & {
        import?: string[] | undefined;
    })[] | undefined;
    size?: string | undefined;
    cropMarks?: boolean | undefined;
    bleed?: string | undefined;
    cropOffset?: string | undefined;
    css?: string | undefined;
    style?: string | undefined;
    userStyle?: string | undefined;
    singleDoc?: boolean | undefined;
    quick?: boolean | undefined;
    pressReady?: boolean | undefined;
    title?: string | undefined;
    author?: string | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    timeout?: number | undefined;
    renderMode?: "local" | "docker" | undefined;
    preflight?: "press-ready" | "press-ready-local" | undefined;
    preflightOption?: string[] | undefined;
    sandbox?: boolean | undefined;
    executableBrowser?: string | undefined;
    image?: string | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
    proxyServer?: string | undefined;
    proxyBypass?: string | undefined;
    proxyUser?: string | undefined;
    proxyPass?: string | undefined;
    logLevel?: "silent" | "info" | "verbose" | "debug" | undefined;
    ignoreHttpsErrors?: boolean | undefined;
    openViewer?: boolean | undefined;
    enableStaticServe?: boolean | undefined;
    enableViewerStartPage?: boolean | undefined;
    vite?: vite.UserConfig | undefined;
    viteConfigFile?: string | boolean | undefined;
    host?: string | boolean | undefined;
    port?: number | undefined;
    logger?: LoggerInterface | undefined;
    disableServerStartup?: boolean | undefined;
}, "VivliostyleInlineConfig">]>;
type VivliostyleInlineConfig = v.InferInput<typeof VivliostyleInlineConfig>;
type ParsedVivliostyleInlineConfig = v.InferOutput<typeof VivliostyleInlineConfig>;
type InlineOptions = Pick<ParsedVivliostyleInlineConfig, 'cwd' | 'config' | 'configData' | 'input' | 'cropMarks' | 'bleed' | 'cropOffset' | 'css' | 'style' | 'userStyle' | 'singleDoc' | 'quick' | 'sandbox' | 'executableBrowser' | 'proxyServer' | 'proxyBypass' | 'proxyUser' | 'proxyPass' | 'logLevel' | 'ignoreHttpsErrors' | 'openViewer' | 'enableStaticServe' | 'enableViewerStartPage' | 'logger' | 'renderMode' | 'preflight' | 'preflightOption' | 'disableServerStartup'>;

export { ArticleEntryConfig, BrowserType, BuildTask, ContentsEntryConfig, CopyAssetConfig, CoverConfig, CoverEntryConfig, EntryConfig, type InlineOptions, type InputFormat, LogLevel, OutputConfig, OutputFormat, type ParsedBuildTask, type ParsedVivliostyleConfigSchema, type ParsedVivliostyleInlineConfig, ReadingProgression, RenderMode, ServerConfig, StructuredDocument, StructuredDocumentSection, ThemeConfig, ThemeSpecifier, TocConfig, ValidString, VfmConfig, VfmReplaceRule, VivliostyleConfigSchema, VivliostyleInlineConfig };
